<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
	
	<link rel="apple-touch-icon" sizes="180x180" href="https://www.cyanilux.com/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="https://www.cyanilux.com/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="https://www.cyanilux.com/favicon-16x16.png">
	<link rel="manifest" href="https://www.cyanilux.com/site.webmanifest">
	<meta name="msapplication-TileColor" content="#00aba9">
	<meta name="theme-color" content="#ffffff">
	
	
    <link rel="stylesheet" type="text/css" href="https://www.cyanilux.com/css/style.css?v=5 ">
	
	<meta itemprop="name" content="Writing Shader Code in Universal RP (v2)">
<meta itemprop="description" content="Explains how shader code (ShaderLab &amp; HLSL) is written to support the Universal RP"><meta itemprop="datePublished" content="2021-05-17T00:00:00+00:00" />
<meta itemprop="dateModified" content="2021-05-17T00:00:00+00:00" />
<meta itemprop="wordCount" content="14098"><meta itemprop="image" content="https://www.cyanilux.com/Preview.png">
<meta itemprop="keywords" content="HLSL,URP," />
	
	
	<meta name="twitter:card" content="summary_large_image"/>
	<meta name="twitter:image" content="https://www.cyanilux.com/tutorials/urp-shader-code/Preview.png"/>
<meta name="twitter:title" content="Writing Shader Code in Universal RP (v2)"/>
<meta name="twitter:description" content="Explains how shader code (ShaderLab &amp; HLSL) is written to support the Universal RP"/>

	
<meta property="og:title" content="Writing Shader Code in Universal RP (v2)" />
<meta property="og:description" content="Explains how shader code (ShaderLab &amp; HLSL) is written to support the Universal RP" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.cyanilux.com/tutorials/urp-shader-code/" />

	
        
        
            <meta name="og:image" content="https://www.cyanilux.com/tutorials/urp-shader-code/Preview.png"/>
        
    
<meta property="article:published_time" content="2021-05-17T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-05-17T00:00:00+00:00" />
	
	
	
    
    
    <title>Writing Shader Code in Universal RP (v2) | Cyanilux</title>
	
	
	
		
		
		<meta name="description" content="Explains how shader code (ShaderLab &amp; HLSL) is written to support the Universal RP. HLSL, URP | Unity Shader Tutorials, @Cyanilux" />
		
	
	
	
	<link rel="canonical" href="https://www.cyanilux.com/tutorials/urp-shader-code/" />
	
	
	<div class="cookie-container">
	  <p>Hello! This site uses cookies related to Twitter (for showing embedded tweets) &amp; Google Analytics (to provide anonymous stats about which web pages are visited, links clicked, etc). These help with improving the website and letting me know what content is popular. 
	  See the <a href="https://www.cyanilux.com/cookies">Cookies & Privacy</a> page for more info.</p>
	  <button class="cookie-accept-btn"><b>Accept</b></button>
	  <button class="cookie-refuse-btn"><b>Refuse</b></button>
	</div>
	
	<script>
	var webStorageSupported = (typeof(Storage) !== undefined);
	
	function setCookie(cname, cvalue, exdays) {
		var d = new Date();
		d.setTime(d.getTime() + (exdays*24*60*60*1000));
		var expires = "expires="+ d.toUTCString();
		document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
	}
	
	function getCookie(cname) {
		var name = cname + "=";
		var decodedCookie = decodeURIComponent(document.cookie);
		var ca = decodedCookie.split(';');
		for(var i = 0; i <ca.length; i++) {
			var c = ca[i];
			while (c.charAt(0) == ' ') {
				c = c.substring(1);
			}
			if (c.indexOf(name) == 0) {
				return c.substring(name.length, c.length);
			}
		}
		return "";
	}
	
	const cookieContainer = document.querySelector(".cookie-container");
	const cookieAcceptButton = document.querySelector(".cookie-accept-btn");
	const cookieRefuseButton = document.querySelector(".cookie-refuse-btn");
	
	cookieAcceptButton.addEventListener("click", () => {
		cookieContainer.classList.remove("active");
	  
		if (webStorageSupported){
			localStorage.setItem("cookiesAccepted", "true");
		}else{
			
			setCookie("cookiesAccepted", "true", 365);
		}
		
		location.reload();
	});
	
	cookieRefuseButton.addEventListener("click", () => {
		cookieContainer.classList.remove("active");
	  
		
		
		document.cookie.split(";").forEach(function(c) { document.cookie = c.replace(/^ +/, "").replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/"); });
		
		if (webStorageSupported){
			localStorage.setItem("cookiesAccepted", "false");
		}else{
			
			setCookie("cookiesAccepted", "false", 14);
		}
	});
	
	var cookie;
	if (webStorageSupported){
		cookie = localStorage.getItem("cookiesAccepted");
	}else{
		cookie = getCookie("cookiesAccepted");
	}
	
	var showBanner = false;
	var cookiesAccepted = false;
	if (cookie == "true"){
		cookiesAccepted = true;
		showBanner = false;
	}else if (cookie === null || cookie == ""){
		showBanner = true;
	}
	
	setTimeout(() => {
		if (showBanner) {
			cookieContainer.classList.add("active");
		}
	}, 1000);
	
	</script>
	
	
	
	<script>
	if (cookiesAccepted){
		
		document.write("<script async src=\"https://www.googletagmanager.com/gtag/js?id=G-11MK1LK6C3\"><\/script>" +
		"<script>\n"+
		"window.dataLayer = window.dataLayer || [];\n" +
		"function gtag(){dataLayer.push(arguments);}\n" +
		"gtag('js', new Date());\n" +
		"gtag('config', 'G-11MK1LK6C3', { 'anonymize_ip': true });\n" + 
		"<\/script>");
	}
	</script>
	
</head>
    <body>
        
<div class="header">
	<div class="logo-header-div"> 
	<a class="link-plain" href="https://www.cyanilux.com">
		<img class="logo" alt="Logo" width="128" height="128" src="https://www.cyanilux.com/logo-small.png"/>
	</a>
	<div class="logo-text-div">
		<h1 class="title-no-margin">
			<a class="logo-text" href="https://www.cyanilux.com">Cyanilux</a>
		</h1>
		<b class="logo-subtext">Game Dev Blog &amp; Tutorials</b>
	</div>
	</div>
	
	<div class="nav-links-div">
	<nav id="nav-links" class="nav-links">
		<ul>
			
			<li><a class="nav-link" href="https://twitter.com/Cyanilux">
			<img src="https://www.cyanilux.com/logo-twitter.png" alt="Twitter"></img>
			</a>
			</li>
			
			<li><a class="nav-link" href="https://mastodon.gamedev.place/@Cyanilux">
			<img src="https://www.cyanilux.com/logo-mastodon.png" alt="Mastodon"></img>
			</a>
			</li>
			
			<li><a class="nav-link" href="http://discord.gg/2V93q9w">
			<img src="https://www.cyanilux.com/logo-discord.png" alt="Discord"></img>
			</a>
			</li>
			
			<li><a class="nav-link" href="https://github.com/Cyanilux">
			<img src="https://www.cyanilux.com/logo-github.png" alt="Github"></img>
			</a>
			</li>
			
		</ul>
	</nav>
	</div>
	
	<nav id="nav" class="nav">
	<ul>
		
		<li><b><a class="nav-link" href="https://www.cyanilux.com/contents/">
		Contents
		</a></b>
		</li>
		
		<li><b><a class="nav-link" href="https://www.cyanilux.com/recent/">
		Recent Posts
		</a></b>
		</li>
		
		<li><b><a class="nav-link" href="https://www.cyanilux.com/resources/">
		Resources
		</a></b>
		</li>
		
		<li><b><a class="nav-link" href="https://www.cyanilux.com/faq/">
		FAQ
		</a></b>
		</li>
		
	</ul>
	</nav>
</div>
        <div class="content">
        

<h1>Writing Shader Code in Universal RP (v2)</h1>
<div class="post-metadata">


<div class="tag" style="background-color:#505050;">
	<a href="https://www.cyanilux.com/tutorials/posts/" style="text-decoration: none; color:#eeeeee;">
	Posts
	</a>
</div>




	<div class="tag" style="background-color:#108010;">
	
	<a href="https://www.cyanilux.com/tags/hlsl" style="text-decoration: none; color:#eeeeee;">
	HLSL
	</a>
	</div>

	<div class="tag" style="background-color:#00aabb;">
	
	<a href="https://www.cyanilux.com/tags/urp" style="text-decoration: none; color:#eeeeee;">
	URP
	</a>
	</div>



<div style="width:10px"></div>


<time datetime="2021-05-17">&#128337 May 17, 2021</time>

</div>
<p>Many shader code tutorials online are intended to be used in Unity’s <strong>Built-in Render Pipeline</strong> and might not work in the <strong>Universal Render Pipeline</strong> – They’ll either produce magenta errors or at least won’t be compatible with the <a href="https://www.cyanilux.com/tutorials/intro-to-shaders/#srp-batcher">SRP Batcher</a>, which batches the setup between draw calls for each shader/material, so rendering many objects with that shader will be more performant.</p>
<p>You can check if a shader is compatible with the SRP Batcher by looking in the <strong>Inspector</strong> when the shader is selected in the <strong>Project</strong> window. And you can check objects are being batched correctly via the <a href="https://docs.unity3d.com/Manual/FrameDebugger.html">Frame Debugger</a> window. If the shader is <strong>Unlit</strong> and doesn&rsquo;t use any properties (except textures) it may already be compatible.</p>
<p>If not, then ideally it should be re-written. Any shaders using the Surface Shader template (<code>#pragma surface</code> function) also aren&rsquo;t compatible with URP and will need rewriting into a vertex/fragment one. Using Shader Graph can be easier, but it doesn&rsquo;t have access to everything and some people may prefer writing code instead.</p>
<p>If you aren&rsquo;t that familiar with shaders, see my <a href="https://www.cyanilux.com/tutorials/intro-to-shaders">Intro to Shaders</a> post first, and consider using Shader Graph as it should be easier for beginners. I&rsquo;ve got an <a href="https://www.cyanilux.com/tutorials/intro-to-shader-graph">Intro to Shader Graph</a> post too.</p>
<p>If you are already familiar with writing shaders for the <strong>Built-in Render Pipeline</strong> you may want to skip to the final sections for summaries of differences, list of functions and templates you can use. No credit is required but would be greatly appreciated. If this article is helpful, please share it with others too!</p>
<div class="notice">
<div style="background-color: #303030; margin-right: 10px;">
<div class="notice-exclamation">
!
</div>
</div>
<div style="margin: 5px;">
This post is an improved version of my <a href="https://cyangamedev.wordpress.com/2020/06/05/urp-shader-code/">old wordpress article</a> of the same name. All on a single page, more detailed, better formatting, and no annoying ads. There&rsquo;s a few sections I might rewrite further but enjoy! 💙
</div>
</div>
<h3 id="sections-">Sections :</h3>
<p class="">
<!-- bit of a hack to make the spacing better for list -->
<font style="line-height:1.5">
</p>
<ul>
<li><a href="#shaderlab">ShaderLab</a>
<ul>
<li><a href="#properties">Properties</a></li>
<li><a href="#subshader">SubShader</a>
<ul>
<li><a href="#render-pipeline">Render Pipeline</a></li>
<li><a href="#queue">Queue</a></li>
</ul>
</li>
<li><a href="#pass">Pass</a>
<ul>
<li><a href="#lightmode-tag">LightMode Tag</a></li>
<li><a href="#cull">Cull</a></li>
<li><a href="#depth-test-write">Depth Test/Write</a> (ZTest, ZWrite &amp; Offset)</li>
<li><a href="#blend">Blend &amp; Transparency</a> (Blend, BlendOp)</li>
</ul>
</li>
<li><a href="#multi-pass">Multi-Pass</a></li>
</ul>
</li>
<li><a href="#hlsl">HLSL</a>
<ul>
<li><a href="#hlslprogram">HLSLPROGRAM &amp; HLSLINCLUDE</a></li>
<li><a href="#variables">Variables</a>
<ul>
<li><a href="#scalar">Scalar</a></li>
<li><a href="#vector">Vector</a></li>
<li><a href="#texture-objects">Texture Objects</a></li>
<li><a href="#matrix">Matrix</a></li>
<li><a href="#array">Array</a></li>
<li><a href="#buffer">Buffer</a></li>
</ul>
</li>
<li><a href="#functions">Functions</a></li>
<li><a href="#unitypermaterial-cbuffer">UnityPerMaterial CBUFFER</a></li>
<li><a href="#structs">Structs</a>
<ul>
<li><a href="#attributes">Attributes (VertexInput)</a></li>
<li><a href="#varyings">Varyings (FragmentInput)</a></li>
<li><a href="#fragment-output">FragmentOutput</a></li>
</ul>
</li>
<li><a href="#vertex-shader">Vertex Shader</a></li>
<li><a href="#fragment-shader">Fragment Shader</a></li>
<li><a href="#keywords">Keywords &amp; Shader Variants</a>
<ul>
<li><a href="#multi-compile">Multi Compile</a></li>
<li><a href="#shader-feature">Shader Feature</a></li>
<li><a href="#shader-variants">Shader Variants</a></li>
<li><a href="#keyword-limits">Keyword Limits</a></li>
</ul>
</li>
<li><a href="#lighting">Lighting Introduction</a>
<ul>
<li><a href="#data-structs">Surface Data &amp; Input Data</a></li>
<li><a href="#initalize-input-data">InitializeInputData</a></li>
<li><a href="#simple-lighting">Simple Lighting</a></li>
<li><a href="#pbr-lighting">PBR Lighting</a></li>
</ul>
</li>
<li><a href="#other-passes">Other Passes</a>
<ul>
<li><a href="#shadowcaster">ShadowCaster</a></li>
<li><a href="#depthonly">DepthOnly</a></li>
<li><a href="#depthnormals">DepthNormals</a></li>
<li><a href="#meta">Meta</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#summary">Summary of Built-in vs URP differences</a>
<ul>
<li><a href="#summary-shaderlab">ShaderLab</a></li>
<li><a href="#summary-hlsl">HLSL</a></li>
<li><a href="#summary-keywords">Keywords</a></li>
<li><a href="#summary-functions">Common Functions/Macros</a></li>
</ul>
</li>
<li><a href="#templates">Templates</a></li>
</ul>
<p class="">
</font>
</p>
<hr>
<h1 id="shaderlab">ShaderLab</h1>
<p>Shader files in Unity are written using two languages. A unity-specific <strong>ShaderLab</strong> language is used define the shader properties, subshaders and passes, while actual shader code is written in <strong>HLSL (High Level Shading Language)</strong>.</p>
<p>The ShaderLab syntax hasn’t changed much compared to the built-in pipeline. Unity provides <a href="https://docs.unity3d.com/Manual/SL-Shader.html">some documentation</a> but I&rsquo;m going over some important parts of it here too. If you are already familiar with ShaderLab you&rsquo;ll mainly want to read the <a href="#render-pipeline">Render Pipeline</a>, <a href="#lightmode-tag">LightMode Tag</a>, and <a href="#multi-pass">Multi Pass</a> sections.</p>
<p>All shaders start with the <strong>Shader</strong> block, which includes a path and name to determine how it appears in the dropdown when changing the shader on the Material in the Inspector window.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>Shader <span style="color:#e6db74">&#34;Custom/UnlitShaderExample&#34;</span> {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Other blocks will go inside here, including a Properties block and various Subshader blocks.</p>
<hr>
<h2 id="properties">Properties</h2>
<p>The Properties block is for any values that need to be exposed to the Material Inspector, so that we can use the same shader for materials with different textures/colours for example.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>Properties {
</span></span><span style="display:flex;"><span><span style="color:#75715e">//  [name] (&#34;[name in inspector]&#34;, [type]) = [default value]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    _BaseMap (<span style="color:#e6db74">&#34;Base Texture&#34;</span>, <span style="color:#ae81ff">2</span>D) <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;white&#34;</span> {}
</span></span><span style="display:flex;"><span>    _BaseColor (<span style="color:#e6db74">&#34;Base Colour&#34;</span>, Color) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0.66</span>, <span style="color:#ae81ff">0.73</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">//  _ExampleDir (&#34;Example Vector&#34;, Vector) = (0, 1, 0, 0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//  _ExampleFloat (&#34;Example Float (Vector1)&#34;, Float) = 0.5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}</span></span></code></pre></div>
<p>We can also change these properties from C# scripts (e.g. using <code>material.SetColor / SetFloat / SetVector / etc</code>). If the properties will be different per material, we must include them in the Properties block as well as the UnityPerMaterial CBUFFER to support the SRP Batcher correctly, which will explained later.</p>
<p>If all shaders should share the same value, then we don&rsquo;t have to expose them here. Instead we only define them later in the HLSL code. We can still set them from C# using <code>Shader.SetGlobalColor / SetGlobalFloat / SetGlobalVector / etc</code>.</p>
<p>More information about setting properties from C# can be found in the <a href="https://www.cyanilux.com/tutorials/intro-to-shaders/#properties">Intro to Shaders</a> post.</p>
<hr>
<h2 id="subshader">SubShader</h2>
<p>Our Shader block can include multiple <strong>SubShaders</strong>. Unity will use the first Subshader block that is supported on the GPU. The <strong>RenderPipeline</strong> tag, as I&rsquo;ll explain more in the next section, should also prevent the SubShader from being chosen if the shader shouldn&rsquo;t be used in that pipeline, allowing a shader to have multiple versions for each pipeline.</p>
<p>We can also define a <strong>Fallback</strong> if no SubShaders are supported. If a fallback isn&rsquo;t used, then it’ll show the magenta error shader instead.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>Shader <span style="color:#e6db74">&#34;Custom/UnlitShaderExample&#34;</span> {
</span></span><span style="display:flex;"><span>    Properties { ... }
</span></span><span style="display:flex;"><span>	SubShader { ... }
</span></span><span style="display:flex;"><span>	FallBack <span style="color:#e6db74">&#34;Path/Name&#34;</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Later we&rsquo;ll define passes in each SubShader which can include HLSL code. Inside this we can specify a <a href="https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html">Shader Compile Target</a>. Higher targets support more GPU features but might not be supported on all platforms.</p>
<p>For versions prior to v10, URP used to use the following in all passes :
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Required to compile gles 2.0 with standard SRP library
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// All shaders must be compiled with HLSLcc and currently only gles is not using HLSLcc by default
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#pragma prefer_hlslcc gles
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma exclude_renderers d3d11_9x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma target 2.0</span></span></span></code></pre></div></p>
<p>You can see an example of this in the <a href="https://github.com/Unity-Technologies/Graphics/blob/v8.3.1/com.unity.render-pipelines.universal/Shaders/Lit.shader">URP/Lit shader (v8.3.1)</a>.</p>
<p>With v10+, deferred support has started to be added so it appears the <a href="https://github.com/Unity-Technologies/Graphics/tree/master/com.unity.render-pipelines.universal/Shaders">provided shaders</a> use two SubShaders instead. The first uses this for each pass :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#pragma exclude_renderers gles gles3 glcore
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma target 4.5</span></span></span></code></pre></div>
<p>Basically meaning &ldquo;use this for all platforms except OpenGL ones&rdquo;. The second SubShader uses :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#pragma only_renderers gles gles3 glcore d3d11
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma target 2.0</span></span></span></code></pre></div>
<p>As far as I can tell both SubShaders are indentical, except for these targets and the second SubShader excludes the UniversalGBuffer pass, used for <a href="https://docs.unity3d.com/Manual/RenderTech-DeferredShading.html">deferred rendering</a>, likely because it can&rsquo;t be supported on those platforms at this time (note that link is for the built-in pipeline&rsquo;s deferred rendering, but the technique is the same). For this post/tutorial I&rsquo;m not including this target stuff but it might be important if you&rsquo;re supporting deferred and targetting OpenGL platforms to split it into two SubShaders like the <a href="https://github.com/Unity-Technologies/Graphics/blob/v10.5.0/com.unity.render-pipelines.universal/Shaders/Lit.shader">URP/Lit shader (v10.5.0)</a>.</p>
<p>I&rsquo;m also not using the deferred pass since it hasn&rsquo;t been properly released in URP yet. I&rsquo;ll try to update the post later to include it properly, (but no promises!)</p>
<h3 id="render-pipeline">Render Pipeline</h3>
<p>The <strong>RenderPipeline</strong> tag should prevent the SubShader from being used unless it&rsquo;s intended for the current render pipeline being used. The tag corresponds to the <code>Shader.globalRenderPipeline</code> value which is set when using a Scriptable Render Pipeline.</p>
<p>The value can be set to <strong>&ldquo;UniversalPipeline&rdquo;</strong> (or the old &ldquo;LightweightPipeline&rdquo;) and <strong>&ldquo;HDRenderPipeline&rdquo;</strong>. While I haven&rsquo;t tested, using a different value likely means the SubShader would always be ignored unless a Custom Render Pipeline is used and it sets the <code>Shader.globalRenderPipeline</code> string.</p>
<p>Excluding the tag completely means any pipeline can use it. I&rsquo;m unsure on the behaviour if the tag value is set to a blank string (&quot;&quot;) but it may be the same. There isn&rsquo;t a value for the Built-In RP so if you want to target it I&rsquo;d recommend using the <strong>last SubShader</strong> without the RenderPipeline tag, acting similar to a Fallback. e.g.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>Shader <span style="color:#e6db74">&#34;Custom/UnlitShaderExample&#34;</span> {
</span></span><span style="display:flex;"><span>    Properties { ... }
</span></span><span style="display:flex;"><span>	SubShader {
</span></span><span style="display:flex;"><span>		Tags { <span style="color:#e6db74">&#34;RenderPipeline&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;UniversalPipeline&#34;</span> <span style="color:#e6db74">&#34;Queue&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Geometry&#34;</span> }
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	SubShader {
</span></span><span style="display:flex;"><span>		Tags { <span style="color:#e6db74">&#34;RenderPipeline&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;HDRenderPipeline&#34;</span> <span style="color:#e6db74">&#34;Queue&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Geometry&#34;</span> }
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	SubShader {
</span></span><span style="display:flex;"><span>		Tags { }
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	FallBack <span style="color:#e6db74">&#34;Path/Name&#34;</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Of note : When I did tests previously with the RenderPipeline tag (in Unity 2019.3, URP 7.x), it appeared that if the shader only includes a single SubShader it didn&rsquo;t matter what the tag is set to, it would always try to use it. Unsure if this has been changed.</p>
<p>Also if you see the tag &ldquo;UniversalRenderPipeline&rdquo; mentioned anywhere, this is incorrect so don&rsquo;t use it! It only worked previously because of the issue mentioned above. It was actually even used in official documentation but was quickly fixed as soon as I mentioned it. &lt;3</p>
<p>Unity 2018 versions also seemed to always use the SceneSelectionPass &amp; Picking passes from the first pass regardless of the tag. Unity 2019+ fixed this though, unsure if it was backported but something to be aware of if doing any custom scene selection rendering.</p>
<h3 id="queue">Queue</h3>
<p>The <strong>Queue</strong> tag is important to determine when the object is rendered, though it can also be overriden on the <strong>Material</strong> (via the Inspector, <strong>Render Queue</strong>).</p>
<p>The tag has to be set to one of these predefined names, each of which correspond with a Render Queue value :</p>
<ul>
<li>&ldquo;Background&rdquo; (1000)</li>
<li>&ldquo;Geometry&rdquo; (2000)</li>
<li>&ldquo;AlphaTest&rdquo; (2450)</li>
<li>&ldquo;Transparent&rdquo; (3000)</li>
<li>&ldquo;Overlay&rdquo; (4000)</li>
</ul>
<p>We can also append +N or -N to the name to change the queue value the shader uses. e.g. &ldquo;Geometry+1&rdquo; will be 2001, so rendered after other objects using 2000. &ldquo;Transparent-1&rdquo; would be 2999 so would be rendered before other transparent objects using 3000.</p>
<p>Values up to 2500 are considered <strong>Opaque</strong> so objects using the same queue value render front-to-back (objects nearer the camera render first). This is for optimised rendering so later fragments can be discarded if they fail the depth test (explained in more detail later).</p>
<p>2501 onwards is <strong>Transparent</strong> and renders back-to-front (objects further away are rendered first). Because transparent shaders tend not to use depth test/write, altering the queue will change how the shader sorts with other transparent objects.</p>
<p>You can also find other tags that can be used listed in the <a href="https://docs.unity3d.com/Manual/SL-SubShaderTags.html">Unity SubShaderTags documentation</a>.</p>
<hr>
<h2 id="pass">Pass</h2>
<p>Pass blocks are defined in each SubShader. There can be multiple passes, where each should include a specific tag named <strong>LightMode</strong> which <strong>determines when/how the pass is used</strong> (explained further in the next section).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>SubShader {
</span></span><span style="display:flex;"><span>	Tags { <span style="color:#e6db74">&#34;RenderPipeline&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;UniversalPipeline&#34;</span> <span style="color:#e6db74">&#34;Queue&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Geometry&#34;</span> }
</span></span><span style="display:flex;"><span>	Pass {
</span></span><span style="display:flex;"><span>		Name <span style="color:#e6db74">&#34;Forward&#34;</span>
</span></span><span style="display:flex;"><span>		Tags { <span style="color:#e6db74">&#34;LightMode&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;UniversalForward&#34;</span> }
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	Pass {
</span></span><span style="display:flex;"><span>		Name <span style="color:#e6db74">&#34;ShadowCaster&#34;</span>
</span></span><span style="display:flex;"><span>		Tags { <span style="color:#e6db74">&#34;LightMode&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;ShadowCaster&#34;</span> }
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	Pass {
</span></span><span style="display:flex;"><span>		Name <span style="color:#e6db74">&#34;DepthOnly&#34;</span>
</span></span><span style="display:flex;"><span>		Tags { <span style="color:#e6db74">&#34;LightMode&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;DepthOnly&#34;</span> }
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//UsePass &#34;Universal Render Pipeline/Lit/ShadowCaster&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	...
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>You can also give them an optional <strong>Name</strong> which allows <code>UsePass</code> to be used in a different shader. An example is shown with using the ShadowCaster pass from the URP Lit shader, however I&rsquo;ve commented it out. This is because it actually isn&rsquo;t recommended to use <code>UsePass</code>. In order to keep SRP Batcher compatibility, <strong>all passes in the shader must have the same UnityPerMaterial CBUFFER</strong>, and <code>UsePass</code> currently can break that as it uses the CBUFFER as defined in that previous shader. Instead, you should write each pass yourself or copy it manually. We&rsquo;ll be going over some of these passes in a later section.</p>
<p>Depending on what the shader is for you might not even need additional passes. A shader used in a Blit render feature to apply a fullscreen image effect for example will only need a single pass where the LightMode tag could be left out completely.</p>
<h3 id="lightmode-tag">LightMode Tag</h3>
<p>As mentioned, each pass includes a tag named <strong>LightMode</strong>, which describes to Unity how the pass is used. The Universal Render Pipeline uses the following modes :</p>
<ul>
<li>&ldquo;UniversalForward&rdquo; - Used to render objects in the <strong>Forward</strong> rendering path. Renders geometry with lighting.</li>
<li>&ldquo;ShadowCaster&rdquo; - Used for casting shadows</li>
<li>&ldquo;DepthOnly&rdquo; - Used by the <strong>Depth Prepass</strong> to create the <strong>Depth Texture</strong> (_CameraDepthTexture) if MSAA is enabled or the platform doesn&rsquo;t support copying the depth buffer</li>
<li>&ldquo;DepthNormals&rdquo; - Used by the <strong>Depth Normals Prepass</strong> to create the <strong>Depth Texture</strong> (_CameraDepthTexture) and <strong>Normals Texture</strong> (_CameraNormalsTexture) if a renderer feature requests it (via <code>ConfigureInput(ScriptableRenderPassInput.Normal);</code> in the ScriptableRenderPass, see <a href="https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.universal/Runtime/RendererFeatures/ScreenSpaceAmbientOcclusion.cs">SSAO feature</a> for example)</li>
<li>&ldquo;Meta&rdquo; - Used during Lightmap Baking</li>
<li>&ldquo;Universal2D&rdquo; - Used for rendering when the 2D Renderer is enabled</li>
<li>&ldquo;SRPDefaultUnlit&rdquo; - Default if no LightMode tag is included in a Pass. Can be used to draw extra passes (in both forward/deferred rendering), however this can break SRP Batcher compatibility. See <a href="#multi-pass">Multi-Pass</a> section below</li>
</ul>
<p>Future changes will also add these (v12+?) :</p>
<ul>
<li>&ldquo;UniversalGBuffer&rdquo; - Used to render objects in the <strong>Deferred</strong> rendering path. Renders geometry into multiple buffers without lighting. Lighting is handled later in the path.</li>
<li>&ldquo;UniversalForwardOnly&rdquo; - Similar to &ldquo;UniversalForward&rdquo;, but can be used to render objects as forward even in the Deferred path which is useful if the shader features data that won&rsquo;t fit in the GBuffer, such as Clear Coat normals.</li>
</ul>
<p>I&rsquo;m currently not including a section on the UniversalGBuffer pass since it hasn&rsquo;t been properly released yet. I may update the post in the future (but no promises!)</p>
<p>Tags like &ldquo;Always&rdquo;, &ldquo;ForwardAdd&rdquo;, &ldquo;PrepassBase&rdquo;, &ldquo;PrepassFinal&rdquo;, &ldquo;Vertex&rdquo;, &ldquo;VertexLMRGBM&rdquo;, &ldquo;VertexLM&rdquo; are intended for the Built-In RP and are not supported in URP.</p>
<p>You can also use custom LightMode tag values, which you can trigger to be rendered via a Custom Renderer Feature or the RenderObjects feature that URP provides.</p>
<h3 id="cull">Cull</h3>
<p>Each pass can include <strong>Cull</strong> to control which sides of a triangle is rendered.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span>Pass {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//Cull Back		// Default, back faces are culled</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//Cull Front	// Front faces are culled</span>
</span></span><span style="display:flex;"><span>	Cull Off		<span style="color:#75715e">// No faces are culled. Both sides are rendered.</span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Which faces correspond to the &ldquo;front&rdquo; or &ldquo;back&rdquo; sides depends on the winding order of the vertices per triangle. In Blender, this is determined by the Normals.</p>
<h3 id="depth-test-write">Depth Test/Write</h3>
<p>Each pass can include the depth test (<strong>ZTest</strong>) and depth write (<strong>ZWrite</strong>) operations.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span>Pass {
</span></span><span style="display:flex;"><span>	ZTest LEqual	<span style="color:#75715e">// Default</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// ZTest Less | Greater | GEqual | Equal | NotEqual | Always</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	ZWrite On		<span style="color:#75715e">// Default</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// ZWrite Off</span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Depth test determines how fragments are rendered depending on how their depth value compares to the value in the depth buffer. For example, <strong>LEqual</strong> (which is also the default if not included), will only render fragments if their depth is <strong>less or equal</strong> to the buffer value.</p>
<p>Depth write determines whether the fragment&rsquo;s depth value replaces the value in the buffer when the test passes. With <code>ZWrite Off</code>, the value remains unchanged. This is mainly useful for Transparent objects in order to achieve the correct blending, however this is also why sorting them is difficult and they sometimes can render in the incorrect order.</p>
<p>Also related, the <strong>Offset</strong> operation allows you to offset the depth value with two parameters (factor, units). I&rsquo;m actually not very familiar with it myself, so&hellip; copying the explanation from the docs (sorry) :</p>
<p>Factor scales the maximum Z slope, with respect to X or Y of the polygon, and units scale the minimum resolvable depth buffer value. This allows you to force one polygon to be drawn on top of another although they are actually in the same position. For example <code>Offset 0, -1</code> pulls the polygon closer to the camera, ignoring the polygon’s slope, whereas <code>Offset -1, -1</code> will pull the polygon even closer when looking at a grazing angle.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span>Pass {
</span></span><span style="display:flex;"><span>	Offset <span style="color:#ae81ff">0</span>, -<span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="blend">Blend &amp; Transparency</h3>
<p>For a shader to support transparency, a <strong>Blend</strong> mode can be defined. This determines how the fragment result is combined with existing values in the camera&rsquo;s colour target/buffer. The syntax is :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span>Blend SrcFactor DstFactor
</span></span><span style="display:flex;"><span><span style="color:#75715e">// or</span>
</span></span><span style="display:flex;"><span>Blend SrcFactor DstFactor, SrcFactorA DstFactorA
</span></span><span style="display:flex;"><span><span style="color:#75715e">// to support different factors for Alpha channel</span></span></span></code></pre></div>
<p>Where the shader colour result is multiplied with the <code>SrcFactor</code>, and the existing colour target/buffer pixel is multiplied with the <code>DstFactor</code>. Each of these values is then combined based on a separate <strong>BlendOp</strong> operation, (which defaults to <strong>Add</strong>), to produce the final colour result which replaces the value in the buffer.</p>
<p>The factors can be one of the following :</p>
<ul>
<li><code>One</code></li>
<li><code>Zero</code></li>
<li><code>SrcColor</code></li>
<li><code>SrcAlpha</code></li>
<li><code>DstColor</code></li>
<li><code>DstAlpha</code></li>
<li><code>OneMinusSrcColor</code></li>
<li><code>OneMinusSrcAlpha</code></li>
<li><code>OneMinusDstColor</code></li>
<li><code>OneMinusDstAlpha</code></li>
</ul>
<p>Also see the <a href="https://docs.unity3d.com/Manual/SL-Blend.html">Blend docs page</a> for a list of the supported <code>BlendOp</code> operations if you want to select a different one than <code>Add</code>.</p>
<p>The most common blends include :</p>
<ul>
<li><code>Blend SrcAlpha OneMinusSrcAlpha</code> - Traditional transparency</li>
<li><code>Blend One OneMinusSrcAlpha</code> - Premultiplied transparency</li>
<li><code>Blend One One</code> - Additive</li>
<li><code>Blend OneMinusDstColor One</code> - Soft Additive</li>
<li><code>Blend DstColor Zero</code> - Multiplicative</li>
<li><code>Blend DstColor SrcColor</code> - 2x Multiplicative</li>
</ul>
<p>A few examples :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>Pass {
</span></span><span style="display:flex;"><span>	Blend SrcAlpha OneMinusSrcAlpha <span style="color:#75715e">// (Traditional transparency)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	BlendOp Add <span style="color:#75715e">// (is default anyway)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	This means,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	newBufferColor = (fragColor * fragColor.a) + (bufferColor * (1 - fragColor.a))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	Which in this case is also equal to what a lerp does :
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	newBufferColor = lerp(bufferColor, fragColor, fragColor.a)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	Of note :
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	- If fragColor.a is 0, the bufferColor is not changed.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	- If fragColor.a is 1, fragColor is used fully.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	*/</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>Pass {
</span></span><span style="display:flex;"><span>	Blend One One <span style="color:#75715e">// (Additive)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	BlendOp Add <span style="color:#75715e">// (is default anyway)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	This means,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	newBufferColor = (fragColor * 1) + (bufferColor * 1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	Of note :
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	- Alpha does not affect this blending (though the final alpha value 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	may change, likely affecting DstAlpha if used in the future. Hence why
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	you may want different factors to be used for the alpha channel).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	- In order to not change the bufferColor, fragColor must be black (0,0,0,0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	*/</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<hr>
<h2 id="multi-pass">Multi-Pass</h2>
<p>If you have additional passes without using a LightMode tag (or using SRPDefaultUnlit), it will be used alongside rendering the main UniversalForward one. This is commonly referred to as &ldquo;Multi-pass&rdquo;. However while this may work in URP, it is <strong>not recommended</strong> as again it is something that breaks the SRP Batcher compatibility, which means rendering objects with the shader will be more expensive.</p>
<p>Instead, the recommended way to achieve Multi-pass is via one of the following :</p>
<ul>
<li>A separate shader, applied as a <strong>second material</strong> to the Mesh Renderer. If using submeshes, more materials can be added and it loops back around.</li>
<li><strong>RenderObjects</strong> feature on the Forward Renderer can be used to re-render all Opaque or Transparent objects on a <strong>specific unity Layer</strong> with an <strong>Override Material</strong> (which uses a separate shader). This is only really useful if you want to render a lot of objects with this second pass - don&rsquo;t waste an entire Layer on a single object. Using the Override Material also <strong>will not keep properties/textures</strong> from the previous shader.</li>
<li><strong>RenderObjects</strong> feature again, but instead of an Override Material you can use a <strong>Pass with a custom LightMode tag</strong> in your shader and use the <strong>Shader Tag ID</strong> setting on the feature to render it. This method will keep properties/textures since it&rsquo;s the same shader still, however it is only suitable for code-written shaders as Shader Graph doesn&rsquo;t provide a way to inject custom passes.</li>
</ul>
<hr>
<h1 id="hlsl">HLSL</h1>
<p>Shader code is written using the High Level Shading Language (HLSL) in Unity.</p>
<h2 id="hlslprogram">HLSLPROGRAM &amp; HLSLINCLUDE</h2>
<p>Inside each ShaderLab Pass, we define blocks for HLSL code using HLSLPROGRAM and ENDHLSL tags. Each of these blocks must include a Vertex and Fragment shader. We use the <code>#pragma vertex/fragment</code> to set which function is going to be used.</p>
<p>For built-in pipeline shaders &ldquo;vert&rdquo; and &ldquo;frag&rdquo; are the most common names, but they can be anything. For URP, it tends to use functions like &ldquo;UnlitPassVertex&rdquo; and &ldquo;UnlitPassFragment&rdquo; which is a bit more descriptive of what the shader pass is doing.</p>
<p>Inside the SubShader we can also use HLSLINCLUDE to include the code <strong>in every Pass inside that SubShader</strong>. This is very useful for writing shaders in URP as every pass needs to use the same <code>UnityPerMaterial CBUFFER</code> to have compatibility with the SRP Batcher and this helps us reuse the same code for every pass instead of needing to define it separately. We could alternatively use a separate include file instead too.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>SubShader {
</span></span><span style="display:flex;"><span>	Tags { <span style="color:#e6db74">&#34;RenderPipeline&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;UniversalPipeline&#34;</span> <span style="color:#e6db74">&#34;Queue&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Geometry&#34;</span> }
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	HLSLINCLUDE
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	ENDHLSL
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Pass {
</span></span><span style="display:flex;"><span>		Name <span style="color:#e6db74">&#34;Forward&#34;</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// LightMode tag. Using default here as the shader is Unlit
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// Cull, ZWrite, ZTest, Blend, etc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>		HLSLPROGRAM
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">#pragma vertex UnlitPassVertex
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">#pragma fragment UnlitPassFragment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		...
</span></span><span style="display:flex;"><span>		ENDHLSL
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>We&rsquo;ll discuss the contents of these code block later. For now, we need to go over some of the basics of HLSL which is important to know to be able to understand the later sections.</p>
<hr>
<h2 id="variables">Variables</h2>
<p>In HLSL, we have a few different variable types, the most common consisting of Scalars, Vectors and Matrices. There&rsquo;s also special objects for Textures/Samplers. Arrays and Buffers also exist for passing more data into the shader.</p>
<h3 id="scalar">Scalar</h3>
<p>The scalar types include :</p>
<ul>
<li><code>bool</code> – true or false.</li>
<li><code>float</code> – 32 bit floating point number. Generally used for world space positions, texture coordinates, or scalar computations involving complex functions such as trigonometry or power/exponentiation.</li>
<li><code>half</code> – 16 bit floating point number.  Generally used for short vectors, directions, object space positions, colours.</li>
<li><code>double</code> – 64 bit floating point number. Cannot be used as inputs/outputs, see note here.</li>
<li><code>real</code> – Used in URP/HDRP when a function can support either half or float. It defaults to half (assuming they are supported on the platform), unless the shader specifies “#define PREFER_HALF 0″, then it will use float precision. Many of the common math functions in the ShaderLibrary functions use this type.</li>
<li><code>int</code> – 32 bit signed integer</li>
<li><code>uint</code> – 32 bit unsigned integer (except GLES2, where this isn’t supported, and is defined as an int instead).</li>
</ul>
<p>Also of note :</p>
<ul>
<li><code>fixed</code> – 11(ish) bit fixed point number with -2 to 2 range. Generally used for LDR colours. Is something from the older CG syntax, though all platforms seem to just convert it to half now even in CGPROGRAM. HLSL does not support this but I felt it was important to mention as you&rsquo;ll likely see the &ldquo;fixed&rdquo; type used in shaders written for the Built-In RP, use half instead!</li>
</ul>
<h3 id="vector">Vector</h3>
<p>A vector is created by appending a component size (integer from 1 to 4) to one of these scalar data types. Some examples include :</p>
<ul>
<li><code>float4</code> – (A float vector containing 4 floats)</li>
<li><code>half3</code> - (A half vector, 3 components)</li>
<li><code>int2</code>, etc</li>
<li>Technically <code>float1</code> would also be a one dimensional vector, but as far as I&rsquo;m aware it&rsquo;s equivalent to <code>float</code>.</li>
</ul>
<p>In order to get one of the components of a vector, we can use <code>.x</code>, <code>.y</code>, <code>.z</code>, or <code>.w</code> (or <code>.r</code>, <code>.g</code>, <code>.b</code>, <code>.a</code> instead, which makes more sense when working with colours). We can also use <code>.xy</code> to obtain a vector2 and <code>.xyz</code> to obtain a vector3 from a higher dimensional vector.</p>
<p>We can even take this further and return a vector with components rearranged, which is referred to as swizzling. Here is a few examples :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span>float3 vector = float3(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>); <span style="color:#75715e">// defined a 3 dimensional float vector</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>float3 a = vector.xyz;  <span style="color:#75715e">// or .rgb,		a = (1, 2, 3)</span>
</span></span><span style="display:flex;"><span>float3 b = vector3.zyx; <span style="color:#75715e">// or .bgr,		b = (3, 2, 1)</span>
</span></span><span style="display:flex;"><span>float3 c = vector.xxx;  <span style="color:#75715e">// or .rrr,		c = (1, 1, 1)</span>
</span></span><span style="display:flex;"><span>float2 d = vector.zy;   <span style="color:#75715e">// or .bg,		d = (3, 2)</span>
</span></span><span style="display:flex;"><span>float4 e = vector.xxzz; <span style="color:#75715e">// or .rrbb,	e = (1, 1, 3, 3)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span>  f  = vector.y;   <span style="color:#75715e">// or .g,		f = 2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Note that mixing xyzw/rgba is not allowed.</span></span></span></code></pre></div>
<h3 id="matrix">Matrix</h3>
<p>A matrix is created by appending two sizes (integers between 1 and 4) to the scalar, separated by an &ldquo;x&rdquo;. The first integer is the number of <strong>rows</strong>, while the second is the number of <strong>columns</strong> in the matrix. For example :</p>
<ul>
<li><code>float4x4</code> – 4 rows, 4 columns</li>
<li><code>int4x3</code> – 4 rows, 3 columns</li>
<li><code>half2x1</code> – 2 rows, 1 column</li>
<li><code>float1x4</code> – 1 row, 4 columns</li>
</ul>
<p>Matrices are used for transforming between different spaces. If you aren&rsquo;t very familiar with them, I&rsquo;d recommend looking at <a href="https://catlikecoding.com/unity/tutorials/rendering/part-1/">this tutorial by CatlikeCoding</a>.</p>
<p>Unity has built-in transformation matrices which are used for transforming between common spaces, such as :</p>
<ul>
<li><code>UNITY_MATRIX_M</code> (or <code>Unity_ObjectToWorld</code>) - <strong>Model</strong> Matrix, Converts from Object space to <strong>World space</strong></li>
<li><code>UNITY_MATRIX_V</code> - <strong>View</strong> Matrix, Converts from World space to <strong>View space</strong></li>
<li><code>UNITY_MATRIX_P</code> - <strong>Projection</strong> Matrix, Converts from View space to <strong>Clip space</strong></li>
<li><code>UNITY_MATRIX_VP</code> - <strong>View Projection</strong> Matrix, Converts from World space to <strong>Clip space</strong></li>
</ul>
<p>Also inverse versions :</p>
<ul>
<li><code>UNITY_MATRIX_I_M</code> (or <code>unity_WorldToObject</code>) - <strong>Inverse Model</strong> Matrix, Converts from World space to <strong>Object space</strong></li>
<li><code>UNITY_MATRIX_I_V</code> - <strong>Inverse View</strong> Matrix, Converts from View space to <strong>World space</strong></li>
<li><code>UNITY_MATRIX_I_P</code> - <strong>Inverse Projection</strong> Matrix, Converts from Clip space to View space</li>
<li><code>UNITY_MATRIX_I_VP</code> - Inverse View Projection Matrix, Converts from Clip space to World space</li>
</ul>
<p>While you can use these matrices to convert between spaces via matrix multiplication (e.g. <code>mul(matrix, float4(position.xyz, 1))</code>), there is also helper functions in the SRP Core ShaderLibrary <a href="https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl">SpaceTransforms.hlsl</a>.</p>
<p>Something to be aware of is when dealing with matrix multiplciation, the order is important. Usually the matrix will be in the first input and the vector in the second. A Vector in the second input is treated like a Matrix consisting of up to 4 rows (depending on the size of the vector), and a single column. A Vector in the first input is instead treated as a Matrix consisting of 1 row and up to 4 columns.</p>
<p>Each component in the matrix can also be accessed using either of the following :
The zero-based row-column position:</p>
<ul>
<li>._m00, ._m01, ._m02, ._m03</li>
<li>._m10, ._m11, ._m12, ._m13</li>
<li>._m20, ._m21, ._m22, ._m23</li>
<li>._m30, ._m31, ._m32, ._m33</li>
</ul>
<p>The one-based row-column position:</p>
<ul>
<li>._11, ._12, ._13, ._14</li>
<li>._21, ._22, ._23, ._24</li>
<li>._31, ._32, ._33, ._34</li>
<li>._41, ._42, ._43, ._44</li>
</ul>
<p>The zero-based array access notation:</p>
<ul>
<li>[0][0], [0][1], [0][2], [0][3]</li>
<li>[1][0], [1][1], [1][2], [1][3]</li>
<li>[2][0], [2][1], [2][2], [2][3]</li>
<li>[3][0], [3][1], [3][2], [3][3]</li>
</ul>
<p>With the first two options, you can also use swizzling. e.g. <code>._m00_m11</code> or <code>._11_22</code>.</p>
<p>Of note, <code>._m03_m13_m23</code> corresponds to the translation part of each matrix. So <code>UNITY_MATRIX_M._m03_m13_m23</code> gives you the World space position of the origin of the GameObject, (assuming there is no static/dynamic batching involved for reasons explained in my <a href="https://www.cyanilux.com/tutorials/intro-to-shaders/#material-instances">Intro to Shaders post</a>).</p>
<h3 id="texture-objects">Texture Objects</h3>
<p>Textures store a colour for each <strong>texel</strong> - basically the same as a pixel, but they are known as texels (short for texture elements) when referring to textures and they also aren’t limited to just two dimensions.</p>
<p>The fragment shader stage runs on a per-fragment/pixel basis, where we can access the colour of a texel with a given coordinate. Textures can have different sizes (widths/heights/depth), but the coordinate used to sample the texture is normalised to a 0-1 range. These are known as Texture Coordinates or UVs. (where U corresponds to the horizontal axis of the texture, while V is the vertical. Sometimes you&rsquo;ll see UVW where W is the third dimension / depth slice of the texture).</p>
<p>The most common texture is a 2D one, which can be defined in URP using the following macros in the global scope (outside any functions) :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>TEXTURE2D(textureName);
</span></span><span style="display:flex;"><span>SAMPLER(sampler_textureName);</span></span></code></pre></div>
<p>For each texture object we also define a <a href="https://docs.unity3d.com/Manual/SL-SamplerStates.html">SamplerState</a> which contains the wrap and filter modes from the texture&rsquo;s import settings. Alternatively, we can define an inline sampler, e.g. <code>SAMPLER(sampler_linear_repeat)</code>.</p>
<p><strong>Filter Modes</strong></p>
<ul>
<li><strong>Point</strong> (or Nearest-Point) : The colour is taken from the nearest texel. The result is blocky/pixellated, but that if you’re sampling pixel art you’ll likely want to use this.</li>
<li><strong>Linear / Bilinear</strong> : The colour is taken as a weighted average of close texels, based on the distance to them.</li>
<li><strong>Trilinear</strong> : The same as Linear/Bilinear, but it is also blends between mipmap levels.</li>
</ul>
<p><strong>Wrap Modes</strong></p>
<ul>
<li><strong>Repeat</strong> : UV values outside of 0-1 will cause the texture to tile/repeat.</li>
<li><strong>Clamp</strong> : UV values outside of 0-1 are clamped, causing the edges of the texture to stretch out.</li>
<li><strong>Mirror</strong> : The texture tiles/repeats while also mirroring at each integer boundary.</li>
<li><strong>Mirror Once</strong> : The texture is mirrored once, then clamps UV values lower than -1 and higher than 2.</li>
</ul>
<p>Later in the fragment shader we use another macro to sample the Texture2D with a uv coordinate that would also be passed through from the vertex shader :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>float4 color <span style="color:#f92672">=</span> SAMPLE_TEXTURE2D(textureName, sampler_textureName, uv);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Note, this can only be used in fragment as it calculates the mipmap level used.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// If you need to sample a texture in the vertex shader, use the LOD version
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// to specify a mipmap (e.g. 0 for full resolution) :
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>float4 color <span style="color:#f92672">=</span> SAMPLE_TEXTURE2D_LOD(textureName, sampler_textureName, uv, <span style="color:#ae81ff">0</span>);</span></span></code></pre></div>
<p>Some other texture types include : Texture2DArray, Texture3D, TextureCube (known as a Cubemap outside of the shader) &amp; TextureCubeArray, each using the following macros :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Texture2DArray
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>TEXTURE2D_ARRAY(textureName);
</span></span><span style="display:flex;"><span>SAMPLER(sampler_textureName);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>float4 color <span style="color:#f92672">=</span> SAMPLE_TEXTURE2D_ARRAY(textureName, sampler_textureName, uv, index);
</span></span><span style="display:flex;"><span>float4 color <span style="color:#f92672">=</span> SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, sampler_textureName, uv, lod);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Texture3D
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>TEXTURE3D(textureName);
</span></span><span style="display:flex;"><span>SAMPLER(sampler_textureName);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>float4 color <span style="color:#f92672">=</span> SAMPLE_TEXTURE3D(textureName, sampler_textureName, uvw);
</span></span><span style="display:flex;"><span>float4 color <span style="color:#f92672">=</span> SAMPLE_TEXTURE3D_LOD(textureName, sampler_textureName, uvw, lod);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// uses 3D uv coord (commonly referred to as uvw)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// TextureCube
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>TEXTURECUBE(textureName);
</span></span><span style="display:flex;"><span>SAMPLER(sampler_textureName);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>float4 color <span style="color:#f92672">=</span> SAMPLE_TEXTURECUBE(textureName, sampler_textureName, dir);
</span></span><span style="display:flex;"><span>float4 color <span style="color:#f92672">=</span> SAMPLE_TEXTURECUBE_LOD(textureName, sampler_textureName, dir, lod);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// uses 3D uv coord (named dir here, as it is typically a direction)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// TextureCubeArray
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>TEXTURECUBE_ARRAY(textureName);
</span></span><span style="display:flex;"><span>SAMPLER(sampler_textureName);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>float4 color <span style="color:#f92672">=</span> SAMPLE_TEXTURECUBE_ARRAY(textureName, sampler_textureName, dir, index);
</span></span><span style="display:flex;"><span>float4 color <span style="color:#f92672">=</span> SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, sampler_textureName, dir, lod);</span></span></code></pre></div>
<h3 id="array">Array</h3>
<p>Arrays can also be defined, and looped through using a for loop. For example :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>float4 _VectorArray[<span style="color:#ae81ff">10</span>]; <span style="color:#75715e">// Vector array
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">float</span> _FloatArray[<span style="color:#ae81ff">10</span>]; <span style="color:#75715e">// Float array
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ArrayExample_float</span>(out <span style="color:#66d9ef">float</span> Out){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">float</span> add <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	[unroll]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>		add <span style="color:#f92672">+=</span> _FloatArray[i];
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	Out <span style="color:#f92672">=</span> add;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>If the size of the loop is fixed (i.e. not based on a variable) and the loop does not exit early, it can be more performant to &ldquo;unroll&rdquo; the loop, which is like copy-pasting the same code multiple times with the index changed.</p>
<p>It’s technically also possible to have other types of arrays, however Unity can only set Vector (float4) and Float arrays from a C# script.</p>
<p>I also recommend to always set them <strong>globally</strong>, using <code>Shader.SetGlobalVectorArray</code> and/or <code>Shader.SetGlobalFloatArray</code> rather than using the <code>material.SetVector/FloatArray</code> versions. The reason for this is arrays cannot be properly included in the UnityPerMaterial CBUFFER (as it requires it to also be defined in the ShaderLab Properties, and arrays aren&rsquo;t supported there). If the objects are batched using the SRP Batcher, multiple materials trying to use different arrays leads to glitchy behaviour where the values will change for all objects depending on what is being rendered on screen. By setting them globally, there can only ever be one array used which avoids this.</p>
<p>Note that these SetXArray methods are also limited to a maximum array size of 1023. If you need larger you might need to try alternative solutions instead, e.g. Compute Buffers (StructuredBuffer), assuming they are supported on the target platform.</p>
<h3 id="buffer">Buffer</h3>
<p>An alternative to arrays, is using <a href="https://docs.unity3d.com/ScriptReference/ComputeBuffer.html">Compute Buffers</a>, which in HLSL is referred to as a <strong>StructuredBuffer</strong> (which is read-only. Alternatively there&rsquo;s <strong>RWStructuredBuffer</strong> for reading &amp; writing but is only supported in pixel/fragment and compute shaders).</p>
<p>You&rsquo;d also need at least <code>#pragma target 4.5</code> to use these. Not all platforms will support compute buffers too (and some might not support StructuredBuffer in vertex shaders). You can use <code>SystemInfo.supportsComputeShaders</code> in C# at runtime to check if the platform supports them.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> Example {
</span></span><span style="display:flex;"><span>	float3 A;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">float</span> B;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>StructuredBuffer<span style="color:#f92672">&lt;</span>Example<span style="color:#f92672">&gt;</span> _BufferExample;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">GetBufferValue</span>(<span style="color:#66d9ef">float</span> Index, out float3 Out) {
</span></span><span style="display:flex;"><span>	Out <span style="color:#f92672">=</span> _BufferExample[Index].A;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>And using this C# for setting it, as a test :</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">32
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">33
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">34
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">using</span> UnityEngine;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">[ExecuteAlways]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BufferTest</span> : MonoBehaviour {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> ComputeBuffer buffer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Test</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> Vector3 A;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">float</span> B;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> OnEnable() {
</span></span><span style="display:flex;"><span>        Test test = <span style="color:#66d9ef">new</span> Test {
</span></span><span style="display:flex;"><span>            A = <span style="color:#66d9ef">new</span> Vector3(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0.5f</span>, <span style="color:#ae81ff">0.5f</span>),
</span></span><span style="display:flex;"><span>            B = <span style="color:#ae81ff">0.1f</span>,
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>        Test test2 = <span style="color:#66d9ef">new</span> Test {
</span></span><span style="display:flex;"><span>            A = <span style="color:#66d9ef">new</span> Vector3(<span style="color:#ae81ff">0.5f</span>, <span style="color:#ae81ff">0.5f</span>, <span style="color:#ae81ff">0</span>),
</span></span><span style="display:flex;"><span>            B = <span style="color:#ae81ff">0.1f</span>,
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>        Test[] data = <span style="color:#66d9ef">new</span> Test[] { test, test2 };
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>        buffer = <span style="color:#66d9ef">new</span> ComputeBuffer(data.Length, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">float</span>) * <span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>        buffer.SetData(data);
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>        GetComponent&lt;MeshRenderer&gt;().sharedMaterial.SetBuffer(<span style="color:#e6db74">&#34;_BufferExample&#34;</span>, buffer);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> OnDisable() {
</span></span><span style="display:flex;"><span>        buffer.Dispose();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></td></tr></table>
</div>
</div>
<p>I&rsquo;m not super familiar with StructuredBuffers so sorry if this section is a bit lacking. I&rsquo;m sure there are resources online that can explain it better!</p>
<hr>
<h2 id="functions">Functions</h2>
<p>Declaring functions in HLSL is fairly similar to C#, however it is important to note that you can only call a function if it&rsquo;s already been declared. You cannot call a function before declaring it so the order of functions and <code>#include</code> files matters!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>float3 <span style="color:#a6e22e">example</span>(float3 a, float3 b){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a <span style="color:#f92672">*</span> b;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Here <code>float3</code> is the return type, &ldquo;example&rdquo; is the function name and inside the brackets are the parameters passed into the function. In the case of no return type, <code>void</code> is used. You can also specify output parameters using <code>out</code> before the parameter type, or <code>inout</code> if you want it to be an input that you can edit and pass back out. (There&rsquo;s also <code>in</code> but we don&rsquo;t need to write it)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Alternative that uses void, with float3 as an output parameter :
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">example</span>(float3 a, float3 b, out float3 Out){
</span></span><span style="display:flex;"><span>    Out <span style="color:#f92672">=</span> a <span style="color:#f92672">*</span> b;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* This might be more useful for passing multiple outputs, 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	though they could also be packed into a struct */</span></span></span></code></pre></div>
<p>You may also see <code>inline</code> before the function return type. This is the default and only modifier a function can actually have, so it’s not important to specify it. It means that the compiler will generate a copy of the function for each call. This is done to reduce the overhead of calling the function.</p>
<p>You may also see functions like :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define EXAMPLE(x, y) ((x) * (y))</span></span></span></code></pre></div>
<p>This is referred to as a <a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-pre-define-2">macro</a>. Macros are handled before compiling the shader and they get replaced with the definition, with any parameters substituted. For example :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> f = EXAMPLE(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>float3 a = float3(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>float3 f2 = EXAMPLE(a, float3(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// just before compiling this becomes :</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> f = ((<span style="color:#ae81ff">3</span>) * (<span style="color:#ae81ff">5</span>));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> a = <span style="color:#66d9ef">float</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>float3 f2 = ((a) * (float3(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>)));
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// An important note, is that the macro has () around x and y.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// This is because we could do :</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> b = EXAMPLE(<span style="color:#ae81ff">1</span>+<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>+<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// which becomes :</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> b = ((<span style="color:#ae81ff">1</span>+<span style="color:#ae81ff">2</span>) * (<span style="color:#ae81ff">3</span>+<span style="color:#ae81ff">4</span>)); <span style="color:#75715e">// 3 * 7, so 21</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// If those () wasn&#39;t included, it would instead be :</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> b = (<span style="color:#ae81ff">1</span>+<span style="color:#ae81ff">2</span>*<span style="color:#ae81ff">3</span>+<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// which equals 11 due to * taking precedence over +</span></span></span></code></pre></div>
<p>Another macro example is :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span><span style="color:#75715e">#define TRANSFORM_TEX(tex,name) (tex.xy * name##_ST.xy + name##_ST.zw)</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Usage :</span>
</span></span><span style="display:flex;"><span>OUT.uv = TRANSFORM_TEX(IN.uv, _MainTex)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// which becomes :</span>
</span></span><span style="display:flex;"><span>OUT.uv = (IN.uv.xy * _MainTex_ST.xy + _MainTex_ST.zw);</span></span></code></pre></div>
<p>The <code>##</code> operator is a special case where macros can be useful. It allows us to concatenate the name and <code>_ST</code> parts, resulting in <code>_MainTex_ST</code> for this input. If the <code>##</code> part was left out, it would just produce <code>name_ST</code>, resulting in an error since that hasn’t be defined. (Of course, _MainTex_ST still also needs to be defined, but that’s the intended behaviour. Appending <code>_ST</code> to the texture name is how Unity handles the tiling and offset values for a texture).</p>
<h2 id="unitypermaterial-cbuffer">UnityPerMaterial CBUFFER</h2>
<p>Moving onto actually creating the shader code, we should first specify the <strong>UnityPerMaterial CBUFFER</strong> inside a <strong>HLSLINCLUDE</strong> block inside the SubShader. This ensures the same CBUFFER is used for all passes, which is important for the shader to be compatible with the SRP Batcher.</p>
<p>The CBUFFER must include all of the <strong>exposed</strong> properties (same as in the Shaderlab Properties block), except textures, though you still need to include the texture tiling &amp; offset values (e.g. _ExampleTexture_ST, where S refers to scale and T refers to translate) and TexelSize (e.g. _ExampleTexture_TexelSize) if they are used.</p>
<p>It cannot include other variables that aren’t exposed.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>HLSLINCLUDE
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>    CBUFFER_START(UnityPerMaterial)
</span></span><span style="display:flex;"><span>    float4 _ExampleTexture_ST; <span style="color:#75715e">// Tiling &amp; Offset, x = TilingX, y = TilingY, z = OffsetX, w = OffsetY
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	float4 _ExampleTexture_TexelSize; <span style="color:#75715e">// x = 1/width, y = 1/height, z = width, w = height.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    float4 _ExampleColor;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">float</span> _ExampleRange;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">float</span> _ExampleFloat;
</span></span><span style="display:flex;"><span>    float4 _ExampleVector;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// etc.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    CBUFFER_END
</span></span><span style="display:flex;"><span>ENDHLSL</span></span></code></pre></div>
<p>Note : While variables don’t <em>have to be exposed</em> to set them via the C# <code>material.SetColor / SetFloat / SetVector / etc</code>, if multiple material instances have different values, this can produce glitchy behaviour as the SRP Batcher will still batch them together when on screen. If you have variables that aren’t exposed – <strong>always</strong> set them using <code>Shader.SetGlobalX</code> functions, so that they remain constant for all material instances. If they need to be different per material, you should expose them via the Shaderlab Properties block and add them to the CBUFFER instead.</p>
<p>In the above code we are also including <strong>Core.hlsl</strong> from the <strong>URP ShaderLibrary</strong> using the #include as shown above. This is basically the URP-equivalent of the built-in pipeline UnityCG.cginc. Core.hlsl (and other ShaderLibrary files it automatically includes) contain a bunch of useful functions and macros, including the <code>CBUFFER_START</code> and <code>CBUFFER_END</code> macros themselves, which is replaced with &ldquo;cbuffer name {&rdquo; and &ldquo;};&rdquo; on platforms that support them, (I think all except GLES2, which makes sense as the SRP Batcher isn&rsquo;t supported for that platform too).</p>
<hr>
<h2 id="structs">Structs</h2>
<p>Before we define the vertex or fragment shader functions we need to define some <strong>structs</strong> which are used to pass data in and out of them. In built-in it is common to create two named &ldquo;appdata&rdquo; and &ldquo;v2f&rdquo; (short for &ldquo;vertex to fragment&rdquo;) while URP shaders tend to use &ldquo;Attributes&rdquo; and &ldquo;Varyings&rdquo; instead. These are just names and usually aren’t too important though, name them &ldquo;VertexInput&rdquo; and &ldquo;FragmentInput&rdquo; if you want.</p>
<p>The URP ShaderLibrary also uses some structs to help organise data needed for certain functions – such as InputData and SurfaceData which are used in lighting/shading calculations, I’ll be going through those in the Lighting section.</p>
<p>Since this is a fairly simple Unlit shader our Attributes and Varyings won’t be all that complicated :</p>
<h3 id="attributes">Attributes (VertexInput)</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Attributes</span> {
</span></span><span style="display:flex;"><span>    float4 positionOS   : POSITION;
</span></span><span style="display:flex;"><span>    float2 uv           : TEXCOORD0;
</span></span><span style="display:flex;"><span>    float4 color        : COLOR;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Don&#39;t forget the semi-colon at the end of the struct here,</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// or you&#39;ll get &#34;Unexpected Token&#34; errors!</span></span></span></code></pre></div>
<p>The <strong>Attributes</strong> struct will be the input to the vertex shader. It allows us to obtain the per-vertex data from the mesh, using the strings (most of which are all in caps) which are known as <a href="https://docs.microsoft.com/en-gb/windows/win32/direct3dhlsl/dx-graphics-hlsl-semantics">semantics</a>.</p>
<p>Can find the full list of semantics via that link, but here&rsquo;s some semantics commonly used in the vertex input :</p>
<ul>
<li><code>POSITION</code> : Vertex position</li>
<li><code>COLOR</code> : Vertex colour</li>
<li><code>TEXCOORD0-7</code> : UVs (aka texture coordinates). A mesh has 8 different UV channels accessed with a value from 0 to 7. Note that in C#, Mesh.uv corresponds to <code>TEXCOORD0</code>. Mesh.uv1 does not exist, the next channel is uv2 which corresponds to <code>TEXCOORD1</code> and so on up to Mesh.uv8 and <code>TEXCOORD7</code>.</li>
<li><code>NORMAL</code> : Vertex Normals (used for lighting calculations. This is unlit currently so isn&rsquo;t needed)</li>
<li><code>TANGENT</code> : Vertex Tangents (used to define &ldquo;tangent space&rdquo;, important for normal maps and parallax effects)</li>
</ul>
<p>There&rsquo;s also some more special semantics, like <code>SV_VertexID</code> (requires <code>#pragma target 3.5</code>), which allows you to obtain an identifer per-vertex (<code>uint</code> type). Useful for use with a ComputeBuffer.</p>
<h3 id="varyings">Varyings (FragmentInput)</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Varyings</span> {
</span></span><span style="display:flex;"><span>    float4 positionCS   : SV_POSITION;
</span></span><span style="display:flex;"><span>    float2 uv           : TEXCOORD0;
</span></span><span style="display:flex;"><span>    float4 color        : COLOR;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Don&#39;t forget the semi-colon at the end of the struct here,</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// or you&#39;ll get &#34;Unexpected Token&#34; errors!</span></span></span></code></pre></div>
<p>The <strong>Varyings</strong> struct will be the input to the fragment shader, and the output of the vertex shader (assuming there’s no geometry shader in-between, which might need another struct, but we aren’t going through that in this post).</p>
<p>Unlike the previous struct, we use <code>SV_POSITION</code> instead of <code>POSITION</code>, which stores the <strong>clip space position</strong> from the vertex shader output. It&rsquo;s important to convert the geometry to fragments/pixels on the screen at the correct location.</p>
<p>We also use the <code>COLOR</code> and/or <code>TEXCOORDn</code> (where n is a number) semantics but unlike before don&rsquo;t have to correspond to the mesh vertex colors / uvs at all. Instead they are used to <strong>interpolate data across the triangle</strong>. <code>NORMAL/TANGENT</code> is typically not used in the Varyings struct, and although I have seen them still work (along with completely custom semantics, e.g. Shader Graph uses <code>INTERPn</code>), it might not supported on all platforms so I&rsquo;d stick to <code>TEXCOORDn</code> to be safe.</p>
<p>Depending on the platform &amp; compile target, the number of interpolators available can vary :</p>
<ul>
<li>OpenGL ES 2.0 (Android), Direct3D 11 9.x level (Windows Phone), and Direct3D 9 Shader Model 2.0 (<code>#pragma target 2.0</code>) supports up to <strong>8</strong> interpolators (e.g. <code>TEXCOORD0-7</code>)</li>
<li>Direct3D 9 Shader Model 3.0 (<code>#pragma target 3.0</code>) supports up to <strong>10</strong> (e.g. <code>TEXCOORD0-9</code>)</li>
<li>OpenGL ES 3.0 (Android) and Metal (iOS) platforms support up to <strong>16</strong> (e.g. <code>TEXCOORD0-15</code>)</li>
<li>Direct3D 10 Shader Model 4.0 (<code>#pragma target 4.0</code>) supports up to <strong>32</strong> (e.g. <code>TEXCOORD0-31</code>)</li>
</ul>
<p>Another useful semantic, used with <code>Cull Off</code>, is <code>VFACE</code> (float type, available in Direct3D 9 Shader Model 3). A negative value means it is a back face, while a positive value indicates a front face. So could use a ternary like <code>(face &gt; 0) ? _ColorFront : _ColorBack</code> to apply colours to different sides. Direct3D 10 has a similar <code>SV_IsFrontFace</code> but is a bool type rather than float.</p>
<p>See the <a href="https://docs.unity3d.com/Manual/SL-ShaderSemantics.html">Shader Semantics docs page</a> and <a href="https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html">Shader Compile Targets docs page</a> for more info.</p>
<h3 id="fragment-output">FragmentOutput</h3>
<p>The fragment shader can also provide an output struct. However it&rsquo;s usually not needed as it typically only uses a single output semantic, <code>SV_Target</code>, which is used to write the fragment/pixel colour to the current render target. In this case we can just define it with the function like :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>half4 <span style="color:#a6e22e">UnlitPassFragment</span>(Varyings input) <span style="color:#f92672">:</span> SV_Target {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// ... // calculate color
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> color;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>It is possible for a shader to output to more than one render target though, known as <strong>Multi Render Target</strong> (MRT). This is used by the Deferred Rendering path, e.g. <a href="https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.universal/ShaderLibrary/UnityGBuffer.hlsl">see UnityGBuffer.hlsl</a> (which isn&rsquo;t fully supported in URP yet).</p>
<p>If not using the deferred path, using MRT would require setup on the C# side, such as using <code>Graphics.SetRenderTarget</code> with a <code>RenderBuffer[]</code> array, or <code>CommandBuffer.SetRenderTarget</code> with a <code>RenderTargetIdentifier[]</code> array. MRT is not supported on all platforms however (e.g. GLES2)</p>
<p>In the shader we would define the MRT output like so :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> FragOut {
</span></span><span style="display:flex;"><span>	half4 color : SV_Target0; 	<span style="color:#75715e">// aka SV_Target
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	half4 color2 : SV_Target1; 	<span style="color:#75715e">// another render target
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>FragOut <span style="color:#a6e22e">UnlitPassFragment</span>(Varyings input) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// ... // calculate color and color2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	FragOut output;
</span></span><span style="display:flex;"><span>	output.color <span style="color:#f92672">=</span> color;
</span></span><span style="display:flex;"><span>	output.color2 <span style="color:#f92672">=</span> color2;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> output;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>It is also possible to change the value used for depth, using the <code>SV_Depth</code> semantic (or <code>SV_DepthGreaterEqual</code> / <code>SV_DepthLessEqual</code> ) as explained in my <a href="https://www.cyanilux.com/tutorials/depth/#depth-output">Depth article</a>.</p>
<hr>
<h2 id="vertex-shader">Vertex Shader</h2>
<p>The main thing that our vertex shader needs to do is convert the object space position from the mesh into a clip space position. This is required in order to correctly render fragments/pixels in the intended screen position.</p>
<p>In built-in shaders you would do this with the <code>UnityObjectToClipPos</code> function, but this has been renamed to <code>TransformObjectToHClip</code> (which you can find in the SRP-core <a href="https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl">SpaceTransforms.hlsl</a>). That said, there’s another way to handle the transform in URP as shown below which makes conversions to other spaces much easier too.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>Varyings <span style="color:#a6e22e">UnlitPassVertex</span>(Attributes IN) {
</span></span><span style="display:flex;"><span>    Varyings OUT;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// alternatively, Varyings OUT = (Varyings)0;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// to initalise all struct inputs to 0.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// otherwise, every variable in the struct must be set
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//OUT.positionCS = TransformObjectToHClip(IN.positionOS.xyz);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Or :
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    VertexPositionInputs positionInputs <span style="color:#f92672">=</span> GetVertexPositionInputs(IN.positionOS.xyz);
</span></span><span style="display:flex;"><span>    OUT.positionCS <span style="color:#f92672">=</span> positionInputs.positionCS;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// which also contains .positionWS, .positionVS and .positionNDC (aka screen position)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Pass through UV/TEXCOORD0 with texture tiling and offset (_BaseMap_ST) applied :
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    OUT.uv <span style="color:#f92672">=</span> TRANSFORM_TEX(IN.uv, _BaseMap);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Pass through Vertex Colours :
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    OUT.color <span style="color:#f92672">=</span> IN.color;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OUT;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>GetVertexPositionInputs computes the position in each of the commonly used spaces. It used to be a part of Core.hlsl, but was separated into it’s own file – <a href="https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderVariablesFunctions.hlsl">ShaderVariablesFunctions.hlsl</a> in URP v9, but this file is automatically included when we include Core.hlsl anyway.</p>
<p>The function uses the object space position from the <code>Attributes</code> as an input and returns a <code>VertexPositionInputs</code> struct, which contains:</p>
<ul>
<li><code>positionWS</code> : the position in <strong>World</strong> space</li>
<li><code>positionVS</code> : the position in <strong>View</strong> space</li>
<li><code>positionCS</code> : the position in <strong>Clip</strong> space</li>
<li><code>positionNDC</code> : the position in <strong>Normalised Device Coordinates</strong>, aka Screen Position. (0,0) in bottom left, (w,w) in top right. Of note, we would pass the position to the fragment stage, then handle the perspective divide (<code>positionNDC.xy / positionNDC.w</code>) so (1,1) is top right instead.</li>
</ul>
<p>For our current unlit shader, we don’t need these other coordinate spaces, but this function is useful for shaders where we do. The unused ones also won’t be included in the compiled shader so there isn’t any unnecessary calculations.</p>
<p>The vertex shader is also responsible for passing data to the fragment, such as the texture coordinates (UV) and vertex colours. The values get interpolated across the triangle, as discussed in the <a href="https://www.cyanilux.com/tutorials/intro-to-shaders/#shader">Intro to Shaders post</a>. For the UVs, we could just do <code>OUT.uv = IN.uv;</code> assuming both are set to <code>float2</code> in the structs, but it&rsquo;s common to include the Tiling and Offset values for the texture which Unity passes into a <code>float4</code> with the texture name + <code>_ST</code> (s referring to scale, and t for translate). In this case, <code>_BaseMap_ST</code> which is also included in our UnityPerMaterial CBUFFER from earlier. In order to apply this to the UV, we could do :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>OUT.uv <span style="color:#f92672">=</span> IN.uv <span style="color:#f92672">*</span> _BaseMap_ST.xy <span style="color:#f92672">+</span> _BaseMap_ST.zw;</span></span></code></pre></div>
<p>But the <code>TRANSFORM_TEX</code> macro can also be used instead, which is included in the Built-in RP as well as URP.</p>
<p>While we don’t need any normal/tangent data for our Unlit shader, there is also <code>GetVertexNormalInputs</code> which can obtain the World space position of the normal, tangent and generated bitangent vectors.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>VertexNormalInputs normalInputs <span style="color:#f92672">=</span> GetVertexNormalInputs(IN.normalOS, IN.tangentOS);
</span></span><span style="display:flex;"><span>OUT.normalWS <span style="color:#f92672">=</span> normalInputs.normalWS;
</span></span><span style="display:flex;"><span>OUT.tangentWS <span style="color:#f92672">=</span> normalInputs.tangentWS;
</span></span><span style="display:flex;"><span>OUT.bitangentWS <span style="color:#f92672">=</span> normalInputs.bitangentWS;</span></span></code></pre></div>
<p>This will be useful later when Lighting is needed. There&rsquo;s also a version of the function which takes only the <code>normalOS</code>, which leaves <code>tangentWS</code> as <code>(1,0,0)</code> and <code>bitangentWS</code> as <code>(0,1,0)</code>, or you could use <code>positionWS = TransformObjectToWorldNormal(IN.normalOS)</code> instead, which is useful if the tangent/bitangent isn&rsquo;t needed (e.g. No normal/bump or parallax mapping effects).</p>
<hr>
<h2 id="fragment-shader">Fragment Shader</h2>
<p>The fragment shader is responsible for determining the colour of the pixel output (including alpha). For unlit shaders this can be a fairly simple solid colour or a colour obtained from sampling an input texture. For lit shaders, it’s a bit more complicated but URP provides some handy functions which I’ll be going through in the Lighting section.</p>
<p>For now since our shader is Unlit, all we need is :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>half4 <span style="color:#a6e22e">UnlitPassFragment</span>(Varyings IN) <span style="color:#f92672">:</span> SV_Target {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Sample BaseMap Texture :
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    half4 baseMap <span style="color:#f92672">=</span> SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, IN.uv);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Tint texture result with Color property and vertex colours :
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> baseMap <span style="color:#f92672">*</span> _BaseColor <span style="color:#f92672">*</span> IN.color;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>This produces a shader which outputs a half4 colour, based on the sampled <code>_BaseMap</code> texture, which is also tinted by the <code>_BaseColor</code> property and interpolated vertex colour. The <code>SAMPLE_TEXTURE2D</code> macro is provided by the ShaderLibrary and returns the colour at the given uv coordinate, since the shader runs per-fragment/pixel.</p>
<p>As mentioned in the <a href="#fragment-output">FragmentOutput</a> section, <code>SV_Target</code> is used to write the fragment/pixel colour to the current render target.</p>
<p>Something that we might also want to do, is discard pixels if their alpha value is below a certain threshold, so that the entire mesh isn’t visible – e.g. for grass/leaf textures on quads. This can be done in opaque shaders as well as transparent, and is usually referred to as <strong>Alpha Clip/Cutout/Cutoff</strong>. If you are familiar with <strong>Shader Graph</strong>, it’s handled with the <strong>Alpha Clip Threshold</strong>. In Shader Code this commonly involves a Float property named <code>_Cutoff</code> (added to Shaderlab Properties as well as the UnityPerMaterial CBUFFER for SRP Batcher-compatibility). This can then be used in the fragment shader :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (_BaseMap.a &lt; _Cutoff){
</span></span><span style="display:flex;"><span>    discard;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// OR</span>
</span></span><span style="display:flex;"><span>clip(_BaseMap.a - _Cutoff);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// inside the fragment function, before returning</span></span></span></code></pre></div>
<p>This is essentially the Unlit Shader Code complete.</p>
<hr>
<h2 id="keywords">Keywords &amp; Shader Variants</h2>
<p>Before we go over Lighting, we need to talk about keywords and shader variants first. In shaders we can specify the <code>#pragma multi_compile</code> and <code>#pragma shader_feature</code> directives which are used to specify <strong>keywords</strong> for toggling certain parts of the shader code &ldquo;on&rdquo; or &ldquo;off&rdquo;. The shader actually gets compiled into multiple versions of the shader, known as <strong>shader variants</strong>. In Unity, we can then enable and disable keywords per material to select which variant gets used.</p>
<p>This is useful as it allows us to write a single shader, but create different versions of it with some features off to save on performance. This needs to be used carefully however, as different shader variants will not batch together. URP uses some of these keywords for toggling features like lighting (i.e. <code>#pragma multi_compile _ _MAIN_LIGHT_SHADOWS</code> prior to v11) and fog (which uses the slightly special <code>#pragma multi_compile_fog</code>, same as in the built-in RP).</p>
<h3 id="multi-compile">Multi Compile</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile _A _B _C (...etc)</span></span></span></code></pre></div>
<p>In this example we are producing three variants of the shader, where _A, _B, and _C are keywords.
We can then use <code>#if defined(KEYWORD)</code> / <code>#ifdef KEYWORD</code> to determine which code is toggled by the keyword. For example :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#ifdef _A
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">// Compile this code if A is enabled
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef _B
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">// Compile this code if B is disabled, aka only in A and C.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Note the extra &#34;n&#34; in the #ifndef, for &#34;if not defined&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">// Compile this code if B is enabled
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if defined(_A) || defined(_C)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">// Compile this code in A or C. (aka the same as the above, assuming there&#39;s no other keywords)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// We have to use the long-form &#34;#if defined()&#34; if we want multiple conditions,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// where || is &#34;or&#34;, &amp;&amp; is &#34;and&#34;, and ! for &#34;not&#34;, similar to C#.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Note however, that since the keywords are defined in one multi_compile statement
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// it&#39;s actually impossible for both to be enabled, so &amp;&amp; wouldn&#39;t make sense here.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* There&#39;s also #elif, for an &#34;else if&#34; statement */</span></span></span></code></pre></div>
<p>URP uses a bunch of multi_compiles, but here is some common ones. Not every shader needs to include all of these, but some of the functions in the ShaderLibrary rely on these keywords being included, otherwise they may skip calculations.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Additional Lights (e.g. Point, Spotlights)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Shadows
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#pragma multi_compile _ _MAIN_LIGHT_SHADOWS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">// Note, v11 changes this to :
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// #pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile _ _SHADOWS_SOFT
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Baked Lightmap
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#pragma multi_compile _ LIGHTMAP_ON
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile _ DIRLIGHTMAP_COMBINED
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile _ LIGHTMAP_SHADOW_MIXING
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile _ SHADOWS_SHADOWMASK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Other
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#pragma multi_compile_fog
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile_instancing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile _ DOTS_INSTANCING_ON
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile _ _SCREEN_SPACE_OCCLUSION</span></span></span></code></pre></div>
<h3 id="shader-feature">Shader Feature</h3>
<p>Shader Features are similar to Multi-Compile, but an additional variant is generated with all keywords disabled and any <strong>unused variants will be not be included in the final build</strong>. This can be useful to keep build times down, but it’s not good to enable/disable these keywords at runtime, since the shader it needs might not be included in the build! If you need to handle keywords at runtime, multi_compile should be used instead.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#pragma shader_feature _A _B (...etc)</span></span></span></code></pre></div>
<p>The above code generates <strong>three</strong> variants, where _A and _B are keywords. While there&rsquo;s only two keywords, an additional variant where both are disabled is also generated. When using Multi-Compile we can also do this, by specifying the first keyword as blank by using one or more underscores (<code>_</code>). e.g.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile _ _A _B</span></span></span></code></pre></div>
<h3 id="shader-variants">Shader Variants</h3>
<p>With each added multi_compile and shader_feature, it produces more and more shader variants for each possible combination of enabled/disabled keywords. Take the following for example :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile _A _B _C
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile _D _E
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma shader_feature _F</span></span></span></code></pre></div>
<p>Here, the first line is producing 3 shader variants. But the second line, needs to produce 2 shader variants for those variants where _D or _E is already enabled. So, A &amp; D, A &amp; E, B &amp; D, B &amp; E, C &amp; D and C &amp; E. That’s now 6 variants.</p>
<p>Third line, is another 2 variants for each of those 6, so we now have a total of 12 shader variants. (While it&rsquo;s only one keyword, it has the additional variant with it disabled since that line is a shader_feature. Some of those variants might also not be included in the build depending on what is used by materials)</p>
<p>Each added multi_compile with 2 keywords will double the amount of variants produced, so a shader that contains 10 of these will result in 1024 shader variants! It’ll need to compile each shader variant that needs to be included in the final build, so will increase build time as well as the size of the build.</p>
<p>If you want to see how many shader variants a shader produces, click the shader and in the inspector there’s a “Compile and Show Code” button, next to that is a small dropdown arrow where it lists the number of included variants. If you click the “skip unused shader_features” you can toggle to see the total number of variants instead.</p>
<p>To assist with reducing the number of variants produced, There is also “vertex” and “fragment” versions of these directives. For example :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile_vertex _ _A
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile_fragment _ _B
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma shader_feature_vertex _C
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma shader_feature_fragment _D</span></span></span></code></pre></div>
<p>In this example, the _A and _C keywords are only being used for the vertex program and _B and _D only for the fragment. Unity tells us that this produces 2 shader variants, although it’s more like one shader variant where both are disabled and two “half” variants when you look at the actual compiled code it seems.</p>
<p>The <a href="https://docs.unity3d.com/Manual/SL-MultipleProgramVariants.html">documentation</a> has some more information on shader variants.</p>
<h3 id="keyword-limits">Keyword Limits</h3>
<p>An important note is there is also a maximum of <strong>256 global keywords per project</strong>, so it can be good to stick to the naming conventions of other shaders to ensure the same keywords are reused rather than defining new ones.</p>
<p>You’ll also notice for many Multi-Compile the first keyword is usually left as just “_”. By leaving the keyword blank, it leaves more space available for other keywords in the 256 maximum. For Shader Features, this is done automatically.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile _ _KEYWORD
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma shader_feature _KEYWORD
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// If you need to know if that keyword is disabled
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// We can then just do :
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef _KEYWORD
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">// aka &#34;#if !defined(_KEYWORD)&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// or &#34;#ifdef _KEYWORD #else&#34; also works too
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ... code ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif</span></span></span></code></pre></div>
<p>We can also avoid using up the maximum keyword count by using <strong>local versions</strong> of the <code>multi_compile</code> and <code>shader_feature</code>. These produce keywords that are local to that shader, but there’s also a maximum of <strong>64 local keywords per shader</strong>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile_local _ _KEYWORD
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma shader_feature_local _KEYWORD
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// There&#39;s also local_fragment/vertex ones too!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#pragma multi_compile_local_vertex _ _KEYWORD
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile_local_fragment _ _KEYWORD
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma shader_feature_local_vertex _KEYWORD
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma shader_feature_local_fragment _KEYWORD</span></span></span></code></pre></div>
<hr>
<h2 id="lighting">Lighting Introduction</h2>
<p>In the built-in pipeline, custom shaders that required lighting/shading was usually handled by <strong>Surface Shaders</strong>. These had the option to choose which lighting model to use, either the physically-based <strong>Standard/StandardSpecular</strong> or <strong>Lambert</strong> (diffuse) and <strong>BlinnPhong</strong> (specular) models. You could also write custom lighting models, which you would use if you wanted to produce a toon shaded result for example.</p>
<p>The Universal RP does not support surface shaders, however the ShaderLibrary does provide functions to help handle a lot of the lighting calculations for us. These are contained in Lighting.hlsl – (which isn’t included automatically with Core.hlsl, it must be included separately).</p>
<p>There are even functions inside that lighting file that can completely handle lighting for us, including <strong>UniversalFragmentPBR</strong> and <strong>UniversalFragmentBlinnPhong</strong>. These functions are really useful but there is still some setup involved, such as the InputData and SurfaceData structures that need to be passed into the functions.</p>
<p>We&rsquo;ll need a bunch of exposed Properties (which should also be added to the CBUFFER) to be able to send data into the shader and alter it per-material. You can check the templates for the exact properties used - for example, <a href="https://github.com/Cyanilux/URP_ShaderCodeTemplates/blob/main/URP_PBRLitTemplate.shader">PBRLitTemplate</a>.</p>
<p>There&rsquo;s also keywords that need to be defined before including the Lighting.hlsl file, to ensure the functions handle all the calculations we want, such as shadows and baked lighting. It&rsquo;s common for a shader to also include some shader feature keywords (not included below but see template) to be able to toggle features, e.g. to avoid unnecessary texture samples and make the shader cheaper.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile _ _MAIN_LIGHT_SHADOWS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">// Note, v11 changes this to :
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// #pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile_fragment _ _ADDITIONAL_LIGHT_SHADOWS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile_fragment _ _SHADOWS_SOFT
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile _ LIGHTMAP_ON
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile _ DIRLIGHTMAP_COMBINED
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile _ LIGHTMAP_SHADOW_MIXING
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile _ SHADOWS_SHADOWMASK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile _ _SCREEN_SPACE_OCCLUSION
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile_fog
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile_instancing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Include Lighting.hlsl
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&#34;</span></span></span></code></pre></div>
<h3 id="data-structs">Surface Data &amp; Input Data</h3>
<p>Both of these <code>UniversalFragmentPBR</code> / <code>UniversalFragmentBlinnPhong</code> functions use two structures to pass data through : <code>SurfaceData</code> and <code>InputData</code>.</p>
<p>The <strong>SurfaceData</strong> struct is responsible for sampling textures and providing the same inputs as you&rsquo;d find on the URP/Lit shader. Specifically it contains the following :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SurfaceData</span> {
</span></span><span style="display:flex;"><span>    half3 albedo;
</span></span><span style="display:flex;"><span>    half3 specular;
</span></span><span style="display:flex;"><span>    half  metallic;
</span></span><span style="display:flex;"><span>    half  smoothness;
</span></span><span style="display:flex;"><span>    half3 normalTS;
</span></span><span style="display:flex;"><span>    half3 emission;
</span></span><span style="display:flex;"><span>    half  occlusion;
</span></span><span style="display:flex;"><span>    half  alpha;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// And added in v10 :</span>
</span></span><span style="display:flex;"><span>    half  clearCoatMask;
</span></span><span style="display:flex;"><span>    half  clearCoatSmoothness;
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>Note that you don&rsquo;t need to include this code, as this struct is part of the ShaderLibrary and we can instead include the file it is contained in. Prior to v10, the struct existed in <a href="https://github.com/Unity-Technologies/Graphics/blob/v8.3.1/com.unity.render-pipelines.universal/ShaderLibrary/SurfaceInput.hlsl">SurfaceInput.hlsl</a> but the functions in Lighting.hlsl did not actually make use of it.</p>
<p>While you could still use the struct, you would instead need to do :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>half4 color <span style="color:#f92672">=</span> UniversalFragmentPBR(inputData, surfaceData.albedo, surfaceData.metallic, surfaceData.specular,
</span></span><span style="display:flex;"><span>    surfaceData.smoothness, surfaceData.occlusion, surfaceData.emission, surfaceData.alpha);</span></span></code></pre></div>
<p>In v10+ the struct moved to it&rsquo;s own file, <a href="https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.universal/ShaderLibrary/SurfaceData.hlsl">SurfaceData.hlsl</a>, and the <code>UniversalFragmentPBR</code> function was updated so we can simply pass both structs through instead (for the <code>UniversalFragmentBlinnPhong</code> function a SurfaceData version is being added in v12 but current versions will need to split it. Examples shown later).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>half4 color <span style="color:#f92672">=</span> UniversalFragmentPBR(inputData, surfaceData);</span></span></code></pre></div>
<p>We can still include <strong>SurfaceInput.hlsl</strong> instead though, as SurfaceData.hlsl will automatically be included by that file too, and it also contains the <code>_BaseMap</code>, <code>_BumpMap</code> and <code>_EmissionMap</code> texture definitions for us and some functions to assist with sampling them. We&rsquo;ll of course still need the Lighting.hlsl include too in order to have access to those functions.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/SurfaceInput.hlsl&#34;</span></span></span></code></pre></div>
<p>The <strong>InputData</strong> struct is used to pass some extra things through that are required for lighting calculations. In v10, in includes the following :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">InputData</span> {
</span></span><span style="display:flex;"><span>    float3  positionWS;
</span></span><span style="display:flex;"><span>    half3   normalWS;
</span></span><span style="display:flex;"><span>    half3   viewDirectionWS;
</span></span><span style="display:flex;"><span>    float4  shadowCoord;
</span></span><span style="display:flex;"><span>    half    fogCoord;
</span></span><span style="display:flex;"><span>    half3   vertexLighting;
</span></span><span style="display:flex;"><span>    half3   bakedGI;
</span></span><span style="display:flex;"><span>    float2  normalizedScreenSpaceUV;
</span></span><span style="display:flex;"><span>    half4   shadowMask;
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>Again, we don&rsquo;t need to include this code as it&rsquo;s already in <a href="https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.universal/ShaderLibrary/Input.hlsl">Input.hlsl</a> and that&rsquo;s automatically included when we include Core.hlsl anyway.</p>
<p>Since the lighting functions use these structs, we&rsquo;ll need to create them and set each variable it contains. To be more organised, we should do this in separate functions then call them in the fragment shader. The exact contents of the functions can vary slightly depending on what is actually needed for the lighting model.</p>
<p>For now I&rsquo;m leaving the functions blank to first better see how the file is structured. The next few sections will go through the contents of the <code>InitializeSurfaceData</code> and <code>InitializeInputData</code> functions.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Includes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/SurfaceInput.hlsl&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Attributes, Varyings, Texture definitions etc.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Functions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// SurfaceData &amp; InputData
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InitializeSurfaceData</span>(Varyings IN, out SurfaceData surfaceData){
</span></span><span style="display:flex;"><span>	surfaceData <span style="color:#f92672">=</span> (SurfaceData)<span style="color:#ae81ff">0</span>; <span style="color:#75715e">// avoids &#34;not completely initalized&#34; errors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InitializeInputData</span>(Varyings IN, half3 normalTS, out InputData inputData) {
</span></span><span style="display:flex;"><span>	inputData <span style="color:#f92672">=</span> (InputData)<span style="color:#ae81ff">0</span>; <span style="color:#75715e">// avoids &#34;not completely initalized&#34; errors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Vertex Shader
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Fragment Shader
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>half4 <span style="color:#a6e22e">LitPassFragment</span>(Varyings IN) <span style="color:#f92672">:</span> SV_Target {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Setup SurfaceData
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	SurfaceData surfaceData;
</span></span><span style="display:flex;"><span>	InitializeSurfaceData(IN, surfaceData);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Setup InputData
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	InputData inputData;
</span></span><span style="display:flex;"><span>	InitializeInputData(IN, surfaceData.normalTS, inputData);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Lighting Model, e.g.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	half4 color <span style="color:#f92672">=</span> UniversalFragmentPBR(inputData, surfaceData);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// or
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// half4 color = UniversalFragmentBlinnPhong(inputData, surfaceData); // v12 only
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// half4 color = UniversalFragmentBlinnPhong(inputData, surfaceData.albedo, half4(surfaceData.specular, 1), 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//		surfaceData.smoothness, surfaceData.emission, surfaceData.alpha);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// or something custom
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Handle Fog
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	color.rgb <span style="color:#f92672">=</span> MixFog(color.rgb, inputData.fogCoord);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> color;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>It&rsquo;s also not too important that the functions are void as far as I&rsquo;m aware. We could instead return the struct itself. I kinda prefer it that way, but I thought I&rsquo;d try keeping it more consistent with how the URP/Lit shader code looks.</p>
<p>If you want to organise things further, we could also move all the functions to <strong>separate .hlsl files</strong> and use a <code>#include</code> for it. This would also allow you to reuse that code for multiple shaders, and the Meta pass if you need to support that (discussed in more detail in a later section). At the very least, I&rsquo;d recommend having a hlsl file containing <code>InitializeSurfaceData</code> and it&rsquo;s required functions / texture definitions.</p>
<h3 id="initalize-input-data">InitializeInputData</h3>
<p>As mentioned previously, our <code>InitializeInputData</code> function needs to set each of the variables inside the InputData struct, but this mainly obtaining the data passed through from the vertex stage and using some macros and functions (e.g. in order to handle transformations between spaces).</p>
<p>This struct can also be the same for all lighting models, though I&rsquo;m sure you could leave some parts out, e.g. if you aren&rsquo;t supporting baked lighting or the shadowMask. It is important to note that everything in the InputData struct needs to be initalised, so the first line in the function sets everything to 0 initally to avoid errors. You&rsquo;ll need to be careful then to not miss anything important though. It also helps prevent the shader breaking if an extra variable is added to the struct in future updates to the ShaderLibrary.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if SHADER_LIBRARY_VERSION_MAJOR &lt; 9
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">// These functions were added in URP v9.x versions, if we want to support URP versions before, we need to handle it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// If you&#39;re in v10 you could remove this if you don&#39;t care about supporting prior versions.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// (Note, also using GetWorldSpaceViewDir in Vertex Shader)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Computes the world space view direction (pointing towards the viewer).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>float3 <span style="color:#a6e22e">GetWorldSpaceViewDir</span>(float3 positionWS) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (unity_OrthoParams.w <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Perspective
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> _WorldSpaceCameraPos <span style="color:#f92672">-</span> positionWS;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Orthographic
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		float4x4 viewMat <span style="color:#f92672">=</span> GetWorldToViewMatrix();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> viewMat[<span style="color:#ae81ff">2</span>].xyz;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>half3 <span style="color:#a6e22e">GetWorldSpaceNormalizeViewDir</span>(float3 positionWS) {
</span></span><span style="display:flex;"><span>	float3 viewDir <span style="color:#f92672">=</span> GetWorldSpaceViewDir(positionWS);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (unity_OrthoParams.w <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Perspective
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> half3(normalize(viewDir));
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Orthographic
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> half3(viewDir);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InitializeInputData</span>(Varyings input, half3 normalTS, out InputData inputData) {
</span></span><span style="display:flex;"><span>	inputData <span style="color:#f92672">=</span> (InputData)<span style="color:#ae81ff">0</span>; <span style="color:#75715e">// avoids &#34;not completely initalized&#34; errors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	inputData.positionWS <span style="color:#f92672">=</span> input.positionWS;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#ifdef _NORMALMAP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		half3 viewDirWS <span style="color:#f92672">=</span> half3(input.normalWS.w, input.tangentWS.w, input.bitangentWS.w);
</span></span><span style="display:flex;"><span>		inputData.normalWS <span style="color:#f92672">=</span> TransformTangentToWorld(normalTS,half3x3(input.tangentWS.xyz, input.bitangentWS.xyz, input.normalWS.xyz));
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		half3 viewDirWS <span style="color:#f92672">=</span> GetWorldSpaceNormalizeViewDir(inputData.positionWS);
</span></span><span style="display:flex;"><span>		inputData.normalWS <span style="color:#f92672">=</span> input.normalWS;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	inputData.normalWS <span style="color:#f92672">=</span> NormalizeNormalPerPixel(inputData.normalWS);
</span></span><span style="display:flex;"><span>	viewDirWS <span style="color:#f92672">=</span> SafeNormalize(viewDirWS);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	inputData.viewDirectionWS <span style="color:#f92672">=</span> viewDirWS;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		inputData.shadowCoord <span style="color:#f92672">=</span> input.shadowCoord;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#elif defined(MAIN_LIGHT_CALCULATE_SHADOWS)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		inputData.shadowCoord <span style="color:#f92672">=</span> TransformWorldToShadowCoord(inputData.positionWS);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		inputData.shadowCoord <span style="color:#f92672">=</span> float4(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Fog
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#ifdef _ADDITIONAL_LIGHTS_VERTEX
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		inputData.fogCoord <span style="color:#f92672">=</span> input.fogFactorAndVertexLight.x;
</span></span><span style="display:flex;"><span>    	inputData.vertexLighting <span style="color:#f92672">=</span> input.fogFactorAndVertexLight.yzw;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		inputData.fogCoord <span style="color:#f92672">=</span> input.fogFactor;
</span></span><span style="display:flex;"><span>		inputData.vertexLighting <span style="color:#f92672">=</span> half3(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* in v11/v12?, could use this :
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	#ifdef _ADDITIONAL_LIGHTS_VERTEX
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		inputData.fogCoord = InitializeInputDataFog(float4(inputData.positionWS, 1.0), input.fogFactorAndVertexLight.x);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		inputData.vertexLighting = input.fogFactorAndVertexLight.yzw;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		inputData.fogCoord = InitializeInputDataFog(float4(inputData.positionWS, 1.0), input.fogFactor);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		inputData.vertexLighting = half3(0, 0, 0);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	// Which currently just seems to force re-evaluating fog per fragment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	inputData.bakedGI <span style="color:#f92672">=</span> SAMPLE_GI(input.lightmapUV, input.vertexSH, inputData.normalWS);
</span></span><span style="display:flex;"><span>	inputData.normalizedScreenSpaceUV <span style="color:#f92672">=</span> GetNormalizedScreenSpaceUV(input.positionCS);
</span></span><span style="display:flex;"><span>	inputData.shadowMask <span style="color:#f92672">=</span> SAMPLE_SHADOWMASK(input.lightmapUV);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>It&rsquo;s a bit difficult to go through every function here, so I hope most of this is self-explanatory. The only thing that might not be that clear is the normalizedScreenSpaceUV which is currently only used to sample the <strong>Screen Space Ambient Occlusion</strong> texture later. If you don&rsquo;t need to support that you could leave it out, but it also doesn&rsquo;t hurt to include it. If unused, the compiler will likely remove it anyway.</p>
<p>Also in case it&rsquo;s not clear, <code>bakedGI</code> refers to the <strong>Baked Global Illumination</strong> (baked lighting) and <code>shadowMask</code> refers specifically to when that is set to <a href="https://docs.unity3d.com/Manual/LightMode-Mixed-Shadowmask.html">Shadowmask mode</a> as an additional shadow mask texture is then used. The <code>SAMPLE_GI</code> and <code>SAMPLE_SHADOWMASK</code> macros will change when compiled depending on specific keywords. You can find those functions in <a href="https://github.com/Unity-Technologies/Graphics/blob/v10.5.0/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl">Lighting.hlsl</a> (split/moved to <a href="https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.universal/ShaderLibrary/GlobalIllumination.hlsl">GlobalIllumination.hlsl</a> in v12), and <a href="https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl">Shadows.hlsl</a> of the URP ShaderLibrary.</p>
<h3 id="simple-lighting">Simple Lighting</h3>
<p>The URP/SimpleLit shader uses the <code>UniversalFragmentBlinnPhong</code> function from Lighting.hlsl, which uses the <strong>Lambert</strong> and <strong>Blinn-Phong</strong> lighting models. If you aren&rsquo;t familiar with them I&rsquo;m sure there are better resources online, but I&rsquo;ll attempt to explain them quickly :</p>
<p>Lambert models a perfectly <strong>diffuse</strong> surface, where light is reflected in all directions. This involves a <strong>dot product</strong> between the <strong>light direction</strong> and <strong>normal vector</strong> (both normalised).</p>
<p>Phong models the <strong>specular</strong> part of the surface, where light is reflected more when the <strong>view direction</strong> aligns with the light vector reflected by the normal. Blinn-Phong is a slight alteration where instead of a reflected vector, it uses a <strong>half vector</strong> between the light vector and view direction which is more computationally efficient.</p>
<p>While it can be useful to know how to calculate these lighting models, they can be handled for us by the functions in the URP ShaderLibrary. The <code>UniversalFragmentBlinnPhong</code> function uses both the <code>LightingLambert</code> and <code>LightingSpecular</code> (blinn-phong model) functions included in Lighting.hlsl, which are :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>half3 <span style="color:#a6e22e">LightingLambert</span>(half3 lightColor, half3 lightDir, half3 normal) {
</span></span><span style="display:flex;"><span>    half NdotL <span style="color:#f92672">=</span> saturate(dot(normal, lightDir));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> lightColor <span style="color:#f92672">*</span> NdotL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>half3 <span style="color:#a6e22e">LightingSpecular</span>(half3 lightColor, half3 lightDir, half3 normal, half3 viewDir, half4 specular, half smoothness) {
</span></span><span style="display:flex;"><span>    float3 halfVec <span style="color:#f92672">=</span> SafeNormalize(float3(lightDir) <span style="color:#f92672">+</span> float3(viewDir));
</span></span><span style="display:flex;"><span>    half NdotH <span style="color:#f92672">=</span> half(saturate(dot(normal, halfVec)));
</span></span><span style="display:flex;"><span>    half modifier <span style="color:#f92672">=</span> pow(NdotH, smoothness);
</span></span><span style="display:flex;"><span>    half3 specularReflection <span style="color:#f92672">=</span> specular.rgb <span style="color:#f92672">*</span> modifier;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> lightColor <span style="color:#f92672">*</span> specularReflection;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>We could call these functions by including Lighting.hlsl, or copy the code out, but since the <code>UniversalFragmentBlinnPhong</code> does it for us we can use that instead. We need the two structs to pass into it though. The <code>InitializeInputData</code> function we went through in the section above, but for the <code>InitializeSurfaceData</code> function, it can vary slightly depending on what we need to support (Blinn-Phong doesn&rsquo;t use the metallic like PBR for example). I&rsquo;m using the following :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/SurfaceInput.hlsl&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Textures, Samplers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// (note, BaseMap, BumpMap and EmissionMap is being defined by the SurfaceInput.hlsl include)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>TEXTURE2D(_SpecGlossMap); 	SAMPLER(sampler_SpecGlossMap);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Functions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>half4 <span style="color:#a6e22e">SampleSpecularSmoothness</span>(float2 uv, half alpha, half4 specColor, TEXTURE2D_PARAM(specMap, sampler_specMap)) {
</span></span><span style="display:flex;"><span>	half4 specularSmoothness <span style="color:#f92672">=</span> half4(<span style="color:#ae81ff">0.0</span>h, <span style="color:#ae81ff">0.0</span>h, <span style="color:#ae81ff">0.0</span>h, <span style="color:#ae81ff">1.0</span>h);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#ifdef _SPECGLOSSMAP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		specularSmoothness <span style="color:#f92672">=</span> SAMPLE_TEXTURE2D(specMap, sampler_specMap, uv) <span style="color:#f92672">*</span> specColor;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#elif defined(_SPECULAR_COLOR)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		specularSmoothness <span style="color:#f92672">=</span> specColor;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#ifdef _GLOSSINESS_FROM_BASE_ALPHA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		specularSmoothness.a <span style="color:#f92672">=</span> exp2(<span style="color:#ae81ff">10</span> <span style="color:#f92672">*</span> alpha <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		specularSmoothness.a <span style="color:#f92672">=</span> exp2(<span style="color:#ae81ff">10</span> <span style="color:#f92672">*</span> specularSmoothness.a <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> specularSmoothness;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InitializeSurfaceData</span>(Varyings IN, out SurfaceData surfaceData){
</span></span><span style="display:flex;"><span>	surfaceData <span style="color:#f92672">=</span> (SurfaceData)<span style="color:#ae81ff">0</span>; <span style="color:#75715e">// avoids &#34;not completely initalized&#34; errors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	half4 baseMap <span style="color:#f92672">=</span> SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, IN.uv);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#ifdef _ALPHATEST_ON
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// Alpha Clipping
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		clip(baseMap.a <span style="color:#f92672">-</span> _Cutoff);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	half4 diffuse <span style="color:#f92672">=</span> baseMap <span style="color:#f92672">*</span> _BaseColor <span style="color:#f92672">*</span> IN.color;
</span></span><span style="display:flex;"><span>	surfaceData.albedo <span style="color:#f92672">=</span> diffuse.rgb;
</span></span><span style="display:flex;"><span>	surfaceData.normalTS <span style="color:#f92672">=</span> SampleNormal(IN.uv, TEXTURE2D_ARGS(_BumpMap, sampler_BumpMap));
</span></span><span style="display:flex;"><span>	surfaceData.emission <span style="color:#f92672">=</span> SampleEmission(IN.uv, _EmissionColor.rgb, TEXTURE2D_ARGS(_EmissionMap, sampler_EmissionMap));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	half4 specular <span style="color:#f92672">=</span> SampleSpecularSmoothness(IN.uv, diffuse.a, _SpecColor, TEXTURE2D_ARGS(_SpecGlossMap, sampler_SpecGlossMap));
</span></span><span style="display:flex;"><span>	surfaceData.specular <span style="color:#f92672">=</span> specular.rgb;
</span></span><span style="display:flex;"><span>	surfaceData.smoothness <span style="color:#f92672">=</span> specular.a <span style="color:#f92672">*</span> _Smoothness;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>As mentioned previously, in the fragment shader we can then call all these functions :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>half4 <span style="color:#a6e22e">LitPassFragment</span>(Varyings IN) <span style="color:#f92672">:</span> SV_Target {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Setup SurfaceData
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	SurfaceData surfaceData;
</span></span><span style="display:flex;"><span>	InitializeSurfaceData(IN, surfaceData);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Setup InputData
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	InputData inputData;
</span></span><span style="display:flex;"><span>	InitializeInputData(IN, surfaceData.normalTS, inputData);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Simple Lighting (Lambert &amp; BlinnPhong)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// half4 color = UniversalFragmentBlinnPhong(inputData, surfaceData); // v12 only
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	half4 color <span style="color:#f92672">=</span> UniversalFragmentBlinnPhong(inputData, surfaceData.albedo, half4(surfaceData.specular, <span style="color:#ae81ff">1</span>), 
</span></span><span style="display:flex;"><span>		surfaceData.smoothness, surfaceData.emission, surfaceData.alpha);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	color.rgb <span style="color:#f92672">=</span> MixFog(color.rgb, inputData.fogCoord);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> color;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>For a full example, see the <a href="https://github.com/Cyanilux/URP_ShaderCodeTemplates/blob/main/URP_SimpleLitTemplate.shader">URP_SimpleLitTemplate</a>.</p>
<h3 id="pbr-lighting">PBR Lighting</h3>
<p>The URP/Lit shader uses a more accurate <strong>Physically Based Rendering</strong> (PBR) model, which is based on Lambert and a <a href="http://www.thetenthplanet.de/archives/255">Minimalist CookTorrance model</a>. The exact implementation is slightly different according to the ShaderLibrary. If interested, you can find how it&rsquo;s implemented by looking at the <code>LightingPhysicallyBased</code> function in <a href="https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl">Lighting.hlsl</a> and the DirectBRDFSpecular function in <a href="https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.universal/ShaderLibrary/BRDF.hlsl">BRDF.hlsl</a>.</p>
<p>We don&rsquo;t necessarily need to understand how it&rsquo;s implemented to use it though, we can just call the <code>UniversalFragmentPBR</code> function. As mentioned previously in v10+ it takes the two structs, InputData and SurfaceData. We&rsquo;ve already discussed creating the <code>InitializeInputData</code> function in a couple sections above. For the <code>InitializeSurfaceData</code> we&rsquo;ll use :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/SurfaceInput.hlsl&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Textures, Samplers 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// (note, BaseMap, BumpMap and EmissionMap is being defined by the SurfaceInput.hlsl include)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>TEXTURE2D(_MetallicSpecGlossMap); 	SAMPLER(sampler_MetallicSpecGlossMap);
</span></span><span style="display:flex;"><span>TEXTURE2D(_OcclusionMap); 			SAMPLER(sampler_OcclusionMap);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Functions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>half4 <span style="color:#a6e22e">SampleMetallicSpecGloss</span>(float2 uv, half albedoAlpha) {
</span></span><span style="display:flex;"><span>	half4 specGloss;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#ifdef _METALLICSPECGLOSSMAP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		specGloss <span style="color:#f92672">=</span> SAMPLE_TEXTURE2D(_MetallicSpecGlossMap, sampler_MetallicSpecGlossMap, uv)
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">#ifdef _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			specGloss.a <span style="color:#f92672">=</span> albedoAlpha <span style="color:#f92672">*</span> _Smoothness;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			specGloss.a <span style="color:#f92672">*=</span> _Smoothness;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#else </span><span style="color:#75715e">// _METALLICSPECGLOSSMAP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">#if _SPECULAR_SETUP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			specGloss.rgb <span style="color:#f92672">=</span> _SpecColor.rgb;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			specGloss.rgb <span style="color:#f92672">=</span> _Metallic.rrr;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">#ifdef _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			specGloss.a <span style="color:#f92672">=</span> albedoAlpha <span style="color:#f92672">*</span> _Smoothness;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			specGloss.a <span style="color:#f92672">=</span> _Smoothness;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> specGloss;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>half <span style="color:#a6e22e">SampleOcclusion</span>(float2 uv) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#ifdef _OCCLUSIONMAP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#if defined(SHADER_API_GLES)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> SAMPLE_TEXTURE2D(_OcclusionMap, sampler_OcclusionMap, uv).g;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		half occ <span style="color:#f92672">=</span> SAMPLE_TEXTURE2D(_OcclusionMap, sampler_OcclusionMap, uv).g;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> LerpWhiteTo(occ, _OcclusionStrength);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1.0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InitializeSurfaceData</span>(Varyings IN, out SurfaceData surfaceData){
</span></span><span style="display:flex;"><span>	surfaceData <span style="color:#f92672">=</span> (SurfaceData)<span style="color:#ae81ff">0</span>; <span style="color:#75715e">// avoids &#34;not completely initalized&#34; errors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	half4 albedoAlpha <span style="color:#f92672">=</span> SampleAlbedoAlpha(IN.uv, TEXTURE2D_ARGS(_BaseMap, sampler_BaseMap));
</span></span><span style="display:flex;"><span>	surfaceData.alpha <span style="color:#f92672">=</span> Alpha(albedoAlpha.a, _BaseColor, _Cutoff);
</span></span><span style="display:flex;"><span>	surfaceData.albedo <span style="color:#f92672">=</span> albedoAlpha.rgb <span style="color:#f92672">*</span> _BaseColor.rgb <span style="color:#f92672">*</span> IN.color.rgb;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	surfaceData.normalTS <span style="color:#f92672">=</span> SampleNormal(IN.uv, TEXTURE2D_ARGS(_BumpMap, sampler_BumpMap));
</span></span><span style="display:flex;"><span>	surfaceData.emission <span style="color:#f92672">=</span> SampleEmission(IN.uv, _EmissionColor.rgb, TEXTURE2D_ARGS(_EmissionMap, sampler_EmissionMap));
</span></span><span style="display:flex;"><span>	surfaceData.occlusion <span style="color:#f92672">=</span> SampleOcclusion(IN.uv);
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>	half4 specGloss <span style="color:#f92672">=</span> SampleMetallicSpecGloss(IN.uv, albedoAlpha.a);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#if _SPECULAR_SETUP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		surfaceData.metallic <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span>h;
</span></span><span style="display:flex;"><span>		surfaceData.specular <span style="color:#f92672">=</span> specGloss.rgb;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		surfaceData.metallic <span style="color:#f92672">=</span> specGloss.r;
</span></span><span style="display:flex;"><span>		surfaceData.specular <span style="color:#f92672">=</span> half3(<span style="color:#ae81ff">0.0</span>h, <span style="color:#ae81ff">0.0</span>h, <span style="color:#ae81ff">0.0</span>h);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	surfaceData.smoothness <span style="color:#f92672">=</span> specGloss.a;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Then in the fragment shader :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>half4 <span style="color:#a6e22e">LitPassFragment</span>(Varyings IN) <span style="color:#f92672">:</span> SV_Target {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Setup SurfaceData
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	SurfaceData surfaceData;
</span></span><span style="display:flex;"><span>	InitializeSurfaceData(IN, surfaceData);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Setup InputData
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	InputData inputData;
</span></span><span style="display:flex;"><span>	InitializeInputData(IN, surfaceData.normalTS, inputData);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// PBR Lighting
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	half4 color <span style="color:#f92672">=</span> UniversalFragmentPBR(inputData, surfaceData);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Fog
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	color.rgb <span style="color:#f92672">=</span> MixFog(color.rgb, inputData.fogCoord);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> color;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<hr>
<h2 id="other-passes">Other Passes</h2>
<p>There are other passes that the Universal RP uses, such as the <strong>ShadowCaster</strong>, <strong>DepthOnly</strong>, <strong>DepthNormals</strong> (v10+) and <strong>Meta</strong> passes. We can also create passes with a custom LightMode tag, discussed in the earlier <a href="#multi-pass">Multi-Pass</a> section.</p>
<h3 id="shadowcaster">ShadowCaster</h3>
<p>The pass tagged with <code>&quot;LightMode&quot;=&quot;ShadowCaster&quot;</code> is responsible for allowing the object to cast realtime shadows.</p>
<p>In a section earlier I mentioned that <code>UsePass</code> could be used to trigger the shader to use a pass from a different shader, however since this breaks the SRP Batching compatibility we need to instead define the pass in the shader itself.</p>
<p>I find that the easiest way to handle this is let the <a href="https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.universal/Shaders/ShadowCasterPass.hlsl">ShadowCasterPass.hlsl</a> do the work for us (used by shaders like URP/Lit). It contains the Attributes and Varyings structs and fairly simple Vertex and Fragment shaders, handling the shadow bias offsets and alpha clipping/cutout.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//UsePass &#34;Universal Render Pipeline/Lit/ShadowCaster&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Breaks SRP Batcher compatibility, instead we define the pass ourself :
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>Pass {
</span></span><span style="display:flex;"><span>	Name <span style="color:#e6db74">&#34;ShadowCaster&#34;</span>
</span></span><span style="display:flex;"><span>	Tags { <span style="color:#e6db74">&#34;LightMode&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;ShadowCaster&#34;</span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ZWrite On
</span></span><span style="display:flex;"><span>	ZTest LEqual
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	HLSLPROGRAM
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#pragma vertex ShadowPassVertex
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#pragma fragment ShadowPassFragment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Material Keywords
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#pragma shader_feature _ALPHATEST_ON
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#pragma shader_feature _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// GPU Instancing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#pragma multi_compile_instancing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// (Note, this doesn&#39;t support instancing for properties though. Same as URP/Lit)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// #pragma multi_compile _ DOTS_INSTANCING_ON
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// (This was handled by LitInput.hlsl. I don&#39;t use DOTS so haven&#39;t bothered to support it)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonMaterial.hlsl&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/SurfaceInput.hlsl&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Packages/com.unity.render-pipelines.universal/Shaders/ShadowCasterPass.hlsl&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ENDHLSL
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>The URP/Lit shader usually includes LitInput.hlsl, however this defines many textures that our shader might not use (which would likely be ignored / compiled out anyway) and it also includes a <code>UnityPerMaterial CBUFFER</code> which we&rsquo;ve already defined in our <code>HLSLINCLUDE</code>. This causes redefinition errors so I&rsquo;m instead including a few of the ShaderLibrary files that was included by LitInput.hlsl to make sure the pass still functions without erroring.</p>
<p>CommonMaterial.hlsl is mainly included because of the LerpWhiteTo function is used by Shadows.hlsl when sampling the shadowmap. SurfaceInput.hlsl is included as ShadowCasterPass.hlsl makes use of the <code>_BaseMap</code> and <code>SampleAlbedoAlpha</code> function for the alpha clipping/cutout support.</p>
<p>With this ShadowCaster, our shader should also include the <code>_BaseMap</code>, <code>_BaseColor</code> and <code>_Cutoff</code> properties. If they aren&rsquo;t included then it won&rsquo;t error though as it will use them are global shader properties instead.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>Properties {
</span></span><span style="display:flex;"><span>	[MainTexture] _BaseMap(<span style="color:#e6db74">&#34;Base Map (RGB) Smoothness / Alpha (A)&#34;</span>, <span style="color:#ae81ff">2</span>D) <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;white&#34;</span> {}
</span></span><span style="display:flex;"><span>    [MainColor]   _BaseColor(<span style="color:#e6db74">&#34;Base Color&#34;</span>, Color) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	[Toggle(_ALPHATEST_ON)] _AlphaTestToggle (<span style="color:#e6db74">&#34;Alpha Clipping&#34;</span>, Float) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	_Cutoff (<span style="color:#e6db74">&#34;Alpha Cutoff&#34;</span>, Float) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.5</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}</span></span></code></pre></div>
<p>If our main shader uses vertex displacement, we would also need to handle that in the ShadowCaster pass too or the shadow won&rsquo;t move. This involves swapping the vertex shader out for a custom one, e.g. :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>HLSLPROGRAM
</span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma vertex DisplacedShadowPassVertex </span><span style="color:#75715e">// (instead of ShadowPassVertex)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>Varyings DisplacedShadowPassVertex(Attributes input) {
</span></span><span style="display:flex;"><span>	Varyings output <span style="color:#f92672">=</span> (Varyings)<span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	UNITY_SETUP_INSTANCE_ID(input);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Example Displacement
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	input.positionOS <span style="color:#f92672">+=</span> float4(<span style="color:#ae81ff">0</span>, _SinTime.y, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	output.uv <span style="color:#f92672">=</span> TRANSFORM_TEX(input.texcoord, _BaseMap);
</span></span><span style="display:flex;"><span>	output.positionCS <span style="color:#f92672">=</span> GetShadowPositionHClip(input);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> output;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>ENDHLSL</span></span></code></pre></div>
<h3 id="depthonly">DepthOnly</h3>
<p>The pass tagged with <code>&quot;LightMode&quot;=&quot;DepthOnly&quot;</code> is responsible for writing the object&rsquo;s depth to the <strong>Camera Depth Texture</strong> - specifically, when the depth buffer cannot be copied or MSAA is enabled. If your shader is opaque and uses <code>ZWrite On</code> in the main pass, it should include a DepthOnly pass, regardless of it being lit/unlit. Transparent shaders can also include it but since the depth texture is generated before drawing transparent objects they won&rsquo;t appear in it.</p>
<p>The DepthOnly pass is almost identical to what the ShadowCaster does above, except it does not use the shadow bias offsets in the vertex shader (uses the regular <code>TransformObjectToHClip(IN.positionOS.xyz)</code> instead of <code>GetShadowPositionHClip(input)</code>).</p>
<p>Again similar to the above we can make use of the <a href="https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.universal/Shaders/DepthOnlyPass.hlsl">DepthOnlyPass.hlsl</a> used by shaders like URP/Lit to define the Attributes and Varyings structs and Vertex and Fragment shaders for us.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>Pass {
</span></span><span style="display:flex;"><span>	Name <span style="color:#e6db74">&#34;DepthOnly&#34;</span>
</span></span><span style="display:flex;"><span>	Tags { <span style="color:#e6db74">&#34;LightMode&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;DepthOnly&#34;</span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ColorMask <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	ZWrite On
</span></span><span style="display:flex;"><span>	ZTest LEqual
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	HLSLPROGRAM
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#pragma vertex DepthOnlyVertex
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#pragma fragment DepthOnlyFragment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Material Keywords
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#pragma shader_feature _ALPHATEST_ON
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#pragma shader_feature _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// GPU Instancing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#pragma multi_compile_instancing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// #pragma multi_compile _ DOTS_INSTANCING_ON
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonMaterial.hlsl&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/SurfaceInput.hlsl&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Packages/com.unity.render-pipelines.universal/Shaders/DepthOnlyPass.hlsl&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ENDHLSL
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Again, if we want to support vertex displacement we need a custom vertex shader :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>HLSLPROGRAM
</span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma vertex DisplacedDepthOnlyVertex </span><span style="color:#75715e">// (instead of DepthOnlyVertex)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>Varyings DisplacedDepthOnlyVertex(Attributes input) {
</span></span><span style="display:flex;"><span>	Varyings output <span style="color:#f92672">=</span> (Varyings)<span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	UNITY_SETUP_INSTANCE_ID(input);
</span></span><span style="display:flex;"><span>	UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Example Displacement
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	input.positionOS <span style="color:#f92672">+=</span> float4(<span style="color:#ae81ff">0</span>, _SinTime.y, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	output.uv <span style="color:#f92672">=</span> TRANSFORM_TEX(input.texcoord, _BaseMap);
</span></span><span style="display:flex;"><span>	output.positionCS <span style="color:#f92672">=</span> TransformObjectToHClip(input.position.xyz);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> output;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>ENDHLSL</span></span></code></pre></div>
<h3 id="depthnormals">DepthNormals</h3>
<p>The pass tagged with <code>&quot;LightMode&quot;=&quot;DepthNormals&quot;</code> is responsible for writing the object&rsquo;s depth to the <strong>Camera Depth Texture</strong> and normals to the <strong>Camera Normals Texture</strong> if requested by a <strong>Renderer Feature</strong> on the camera&rsquo;s Forward/Universal Renderer.</p>
<p>For example, the <strong>Screen Space Ambient Occlusion</strong> feature can support using the <strong>Depth Normals</strong> as it&rsquo;s source, or can reconstruct normals from <strong>Depth</strong> (so use the DepthOnly pass instead) which avoids creating an additional buffer / render texture to store that <code>_CameraNormalsTexture</code>.</p>
<p>If you&rsquo;re really sure that you don&rsquo;t need SSAO or other features that might use it you could exclude the pass, but I&rsquo;d recommend supporting it anyway to avoid later confusion when objects aren&rsquo;t appearing in the depth &amp; normals textures!</p>
<p>Similar to the previous passes, we can use the <a href="https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.universal/Shaders/DepthNormalsPass.hlsl">DepthNormalsPass.hlsl</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>Pass {
</span></span><span style="display:flex;"><span>	Name <span style="color:#e6db74">&#34;DepthNormals&#34;</span>
</span></span><span style="display:flex;"><span>	Tags { <span style="color:#e6db74">&#34;LightMode&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;DepthNormals&#34;</span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ZWrite On
</span></span><span style="display:flex;"><span>	ZTest LEqual
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	HLSLPROGRAM
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#pragma vertex DepthNormalsVertex
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#pragma fragment DepthNormalsFragment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Material Keywords
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#pragma shader_feature_local _NORMALMAP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//#pragma shader_feature_local _PARALLAXMAP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//#pragma shader_feature_local _ _DETAIL_MULX2 _DETAIL_SCALED
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#pragma shader_feature_local_fragment _ALPHATEST_ON
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#pragma shader_feature_local_fragment _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// GPU Instancing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#pragma multi_compile_instancing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//#pragma multi_compile _ DOTS_INSTANCING_ON
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonMaterial.hlsl&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/SurfaceInput.hlsl&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Packages/com.unity.render-pipelines.universal/Shaders/DepthNormalsPass.hlsl&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Note if we do any vertex displacement, we&#39;ll need to change the vertex function. e.g. :
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	#pragma vertex DisplacedDepthOnlyVertex (instead of DepthOnlyVertex above)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	Varyings DisplacedDepthOnlyVertex(Attributes input) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		Varyings output = (Varyings)0;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		UNITY_SETUP_INSTANCE_ID(input);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		// Example Displacement
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		input.positionOS += float4(0, _SinTime.y, 0, 0);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		output.uv = TRANSFORM_TEX(input.texcoord, _BaseMap);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		output.positionCS = TransformObjectToHClip(input.position.xyz);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		VertexNormalInputs normalInput = GetVertexNormalInputs(input.normal, input.tangentOS);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		output.normalWS = NormalizeNormalPerVertex(normalInput.normalWS);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		return output;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	*/</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	ENDHLSL
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>It&rsquo;s worth mentioning that newer versions of URP (v12) use <a href="https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.universal/Shaders/LitDepthNormalsPass.hlsl">LitDepthNormalsPass.hlsl</a> instead, which provides support for using the normal map and detail normal map, as well as parallax/height mapping (requiring the additional keywords commented in the above code too).</p>
<h3 id="meta">Meta</h3>
<p>The pass tagged with <code>&quot;LightMode&quot;=&quot;Meta&quot;</code> is used when baking global illumination. If you aren&rsquo;t using baked GI then you could ignore this pass.</p>
<p>For Unlit shaders, you may want to look into using the <a href="https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.universal/Shaders/UnlitMetaPass.hlsl">UnlitMetaPass.hlsl</a> similar to the above passes.</p>
<p>For Lit shaders, we could probably use <a href="https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.universal/Shaders/LitMetaPass.hlsl">LitMetaPass.hlsl</a>, however it wants a <code>InitializeStandardLitSurfaceData</code> function which isn&rsquo;t exactly what we&rsquo;re using and my PBR example also includes vertex colour so we would need to change the Varyings too. Instead I ended up using this instead :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>Pass {
</span></span><span style="display:flex;"><span>	Name <span style="color:#e6db74">&#34;Meta&#34;</span>
</span></span><span style="display:flex;"><span>	Tags{<span style="color:#e6db74">&#34;LightMode&#34;</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Meta&#34;</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Cull Off
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	HLSLPROGRAM
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#pragma vertex UniversalVertexMeta
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#pragma fragment UniversalFragmentMeta
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#pragma shader_feature_local_fragment _SPECULAR_SETUP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#pragma shader_feature_local_fragment _EMISSION
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#pragma shader_feature_local_fragment _METALLICSPECGLOSSMAP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#pragma shader_feature_local_fragment _ALPHATEST_ON
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#pragma shader_feature_local_fragment _ _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//#pragma shader_feature_local _ _DETAIL_MULX2 _DETAIL_SCALED
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#pragma shader_feature_local_fragment _SPECGLOSSMAP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> Attributes {
</span></span><span style="display:flex;"><span>		float4 positionOS   : POSITION;
</span></span><span style="display:flex;"><span>		float3 normalOS     : NORMAL;
</span></span><span style="display:flex;"><span>		float2 uv0          : TEXCOORD0;
</span></span><span style="display:flex;"><span>		float2 uv1          : TEXCOORD1;
</span></span><span style="display:flex;"><span>		float2 uv2          : TEXCOORD2;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">#ifdef _TANGENT_TO_WORLD
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		float4 tangentOS     : TANGENT;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		float4 color		: COLOR;
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> Varyings {
</span></span><span style="display:flex;"><span>		float4 positionCS   : SV_POSITION;
</span></span><span style="display:flex;"><span>		float2 uv           : TEXCOORD0;
</span></span><span style="display:flex;"><span>		float4 color		: COLOR;
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;PBRSurface.hlsl&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/MetaInput.hlsl&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	Varyings <span style="color:#a6e22e">UniversalVertexMeta</span>(Attributes input) {
</span></span><span style="display:flex;"><span>		Varyings output;
</span></span><span style="display:flex;"><span>		output.positionCS <span style="color:#f92672">=</span> MetaVertexPosition(input.positionOS, input.uv1, input.uv2, unity_LightmapST, unity_DynamicLightmapST);
</span></span><span style="display:flex;"><span>		output.uv <span style="color:#f92672">=</span> TRANSFORM_TEX(input.uv0, _BaseMap);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> output;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	half4 <span style="color:#a6e22e">UniversalFragmentMeta</span>(Varyings input) <span style="color:#f92672">:</span> SV_Target {
</span></span><span style="display:flex;"><span>		SurfaceData surfaceData;
</span></span><span style="display:flex;"><span>		InitializeSurfaceData(input, surfaceData);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		BRDFData brdfData;
</span></span><span style="display:flex;"><span>		InitializeBRDFData(surfaceData.albedo, surfaceData.metallic, surfaceData.specular, surfaceData.smoothness, surfaceData.alpha, brdfData);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		MetaInput metaInput;
</span></span><span style="display:flex;"><span>		metaInput.Albedo <span style="color:#f92672">=</span> brdfData.diffuse <span style="color:#f92672">+</span> brdfData.specular <span style="color:#f92672">*</span> brdfData.roughness <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.5</span>;
</span></span><span style="display:flex;"><span>		metaInput.SpecularColor <span style="color:#f92672">=</span> surfaceData.specular;
</span></span><span style="display:flex;"><span>		metaInput.Emission <span style="color:#f92672">=</span> surfaceData.emission;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> MetaFragment(metaInput);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	ENDHLSL
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Where <code>PBRSurface.hlsl</code> is a custom HLSL file in the same folder as the shader file. It contains the <code>InitializeSurfaceData</code> function used in the PBR Lighting section, (as well as the SurfaceInput.hlsl include, Texture/Sampler definitions and functions required by <code>InitializeSurfaceData</code> such as <code>SampleMetallicSpecGloss</code> and <code>SampleOcclusion</code>. The UniversalForward pass also includes that file instead of having that code in the shader.</p>
<hr>
<p>If you&rsquo;ve read this far, thanks! The final section contains a summary of all the differences between URP and the Built-in RP - mostly intended for those that are already familiar with coding shaders, but still a useful summary of everything discussed already too.</p>
<p>I&rsquo;ve also got a section below containing <strong>examples/templates</strong> built from the shader code used in this post.</p>
<hr>
<h1 id="summary">Summary of Built-in vs URP differences</h1>
<h2 id="summary-shaderlab">ShaderLab :</h2>
<ul>
<li>SubShader in URP uses the “RenderPipeline”=”UniversalPipeline” tag</li>
<li>Passes in URP use some different &ldquo;LightMode&rdquo; tags than Built-In. The most common being &ldquo;UniversalForward&rdquo; or left out completely (which defaults it to &ldquo;SRPDefaultUnlit&rdquo;). See <a href="#lightmode-tag">LightMode Tag section</a> for list.</li>
<li>Only the first UniversalForward pass is rendered. Multi-Pass shaders in URP is supported with additional passes using SRPDefaultUnlit, but it breaks SRP Batcher compatibility so is not recommended. See the <a href="#multi-pass">Multi-Pass section</a> for alternatives (i.e Second Material or RenderObjects feature).</li>
<li>URP does not support GrabPass. Instead, a camera opaque texture is captured between rendering opaque and transparent objects which can be used for some distortion/refraction effects for shaders in the transparent queue. <code>#include</code> the <a href="https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareOpaqueTexture.hlsl">DeclareOpaqueTexture.hlsl</a> file and use it&rsquo;s <code>SampleSceneColor</code> function with the ScreenPos (positionNDC) as the uv input. Other transparent objects will not appear in the texture. If you need that, an alternative may be to use a Custom Renderer Feature to render additive distortion objects into an offscreen buffer then distort the final screen result using <code>CommandBuffer.Blit</code>. The idea would be similar to this <a href="https://www.youtube.com/watch?v=xH5uUfeB2Go">Makin&rsquo; Stuff Look Good in Unity video</a> but the code used there is still intended for built-in.</li>
</ul>
<hr>
<h2 id="summary-hlsl">HLSL : </h2>
<ul>
<li>HLSLPROGRAM and ENDHLSL should always be used instead of CGPROGRAM/ENDCG. This is because the latter includes some additional files which conflicts with the URP ShaderLibrary causing redefinitions errors.</li>
<li>The &ldquo;fixed&rdquo; type/precision does not exist in HLSLPROGRAM, use &ldquo;half&rdquo; instead.</li>
<li>URP does not support Surface shaders (<code>#pragma surface</code>), only Vertex/Fragment style shaders. (Geometry and Hull/Domain is also still supported)</li>
<li>Structs used to pass data between the vertex and fragment shaders is commonly called Attributes and Varyings in URP instead of appdata and v2f. This is mainly a naming convention and isn&rsquo;t important though.</li>
<li>Instead of including UnityCG.cginc, use the URP ShaderLibrary. The main one to include is :</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&#34;</span></span></span></code></pre></div>
<ul>
<li>The SRP Batcher batches the setup between draw calls, so rendering multiple objects with the same shader is less expensive. It even batches objects with different materials, but not different shaders / shader variants. In order for a shader to be compatible with this, it must include the URP ShaderLibrary and include a UnityPerMaterial CBUFFER that contains each of the exposed ShaderLab Properties (except textures). It cannot include global shader variables or compatibility breaks. You can check whether a shader is compatible from the Inspector. The CBUFFER must also remain constant for all shader passes, so it is recommended to put it inside HLSLINCLUDE in the SubShader. For example :</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>HLSLINCLUDE
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>    CBUFFER_START(UnityPerMaterial)
</span></span><span style="display:flex;"><span>    float4 _ExampleTexture_ST; <span style="color:#75715e">// Tiling &amp; Offset, x = TilingX, y = TilingY, z = OffsetX, w = OffsetY
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	float4 _ExampleTexture_TexelSize; <span style="color:#75715e">// x = 1/width, y = 1/height, z = width, w = height.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    float4 _ExampleColor;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">float</span> _ExampleRange;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">float</span> _ExampleFloat;
</span></span><span style="display:flex;"><span>    float4 _ExampleVector;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// etc.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    CBUFFER_END
</span></span><span style="display:flex;"><span>ENDHLSL</span></span></code></pre></div>
<ul>
<li>Instead of <code>_MainTex</code>, URP tends to use <code>_BaseMap</code> instead. It&rsquo;s mostly just a naming convention difference, and isn&rsquo;t too important unless you include <a href="https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.universal/ShaderLibrary/SurfaceInput.hlsl">SurfaceInput.hlsl</a> which defines the Albedo, Bump and Emission textures for you. <code>_MainTex</code> should still be used for image effects using <code>CommandBuffer.Blit</code> (i.e. <a href="https://github.com/Cyanilux/URP_BlitRenderFeature">Blit Render Feature</a>) and obtaining the sprite from a SpriteRenderer component.</li>
<li>URP provides macros for defining textures, and uses the DX10+ style syntax which defines a Texture and Sampler separately :</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>TEXTURE2D(_BaseMap);
</span></span><span style="display:flex;"><span>SAMPLER(sampler_BaseMap);</span></span></code></pre></div>
<ul>
<li>And for sampling the texture :</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>half4 baseMap <span style="color:#f92672">=</span> SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, IN.uv);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Can only be used in fragment shader, similar to tex2D() from built-in
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// If sampling in vertex shader, use LOD version to select the mipmap level used :
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>half4 baseMap <span style="color:#f92672">=</span> SAMPLE_TEXTURE2D_LOD(_BaseMap, sampler_BaseMap, IN.uv, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Also tex2Dbias and tex2Dgrad would be equivalent to these macros in URP :
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">float</span> bias <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>half4 baseMap <span style="color:#f92672">=</span> SAMPLE_TEXTURE2D_BIAS(_BaseMap, sampler_BaseMap, IN.uv, bias);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> dpdx <span style="color:#f92672">=</span> ddx(IN.uv.x);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> dpdy <span style="color:#f92672">=</span> ddy(IN.uv.y);
</span></span><span style="display:flex;"><span>half4 baseMap <span style="color:#f92672">=</span> SAMPLE_TEXTURE2D_GRAD(_BaseMap, sampler_BaseMap, IN.uv, dpdx, dpdy);</span></span></code></pre></div>
<ul>
<li>For other texture types (i.e. Texture2DArray, Texture3D, TextureCube, TextureCubeArray), see the <a href="#texture-objects">Texture Objects section</a> for additional macros.</li>
<li>URP includes a function called <code>GetVertexPositionInputs</code> which can be used in the vertex shader to easily obtain transforms to other spaces. Any unused ones won’t be calculated so using this is quite a convenient. For example :</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> Attributes {
</span></span><span style="display:flex;"><span>    float4 positionOS   : POSITION;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> Varyings {
</span></span><span style="display:flex;"><span>    float3 positionCS   : SV_POSITION;
</span></span><span style="display:flex;"><span>    float3 positionWS   : TEXCOORD2;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>Varyings <span style="color:#a6e22e">vert</span>(Attributes IN) {
</span></span><span style="display:flex;"><span>    Varyings OUT;
</span></span><span style="display:flex;"><span>    VertexPositionInputs positionInputs <span style="color:#f92672">=</span> GetVertexPositionInputs(IN.positionOS.xyz);
</span></span><span style="display:flex;"><span>    OUT.positionCS <span style="color:#f92672">=</span> positionInputs.positionCS; <span style="color:#75715e">// Clip Space
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    OUT.positionWS <span style="color:#f92672">=</span> positionInputs.positionWS; <span style="color:#75715e">// World Space
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// OUT.positionVS = positionInputs.positionVS; // View Space
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// OUT.positionNDC = positionInputs.positionNDC; // Normalised Device Coords, aka ScreenPos
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> OUT;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<ul>
<li>Similarly, there is a <code>GetVertexNormalInputs</code>, to obtain the world space normal (<code>normalWS</code>), as well as world space tangent (<code>tangentWS</code>) and bitangent (<code>bitangentWS</code>). If you just need the normal you can use <code>TransformObjectToWorldNormal</code> instead too.</li>
</ul>
<hr>
<h2 id="summary-keywords">Keywords</h2>
<p>Shaders in URP commonly use these keywords for a Lit shader :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Additional Lights (e.g. Point, Spotlights)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Shadows
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#pragma multi_compile _ _MAIN_LIGHT_SHADOWS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">// Note, v11 changes this to :
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// #pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile_fragment _ _ADDITIONAL_LIGHT_SHADOWS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile_fragment _ _SHADOWS_SOFT
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Baked GI
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#pragma multi_compile _ LIGHTMAP_ON
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile _ DIRLIGHTMAP_COMBINED
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile _ LIGHTMAP_SHADOW_MIXING
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile _ SHADOWS_SHADOWMASK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Other
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#pragma multi_compile_fog
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile_instancing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile _ DOTS_INSTANCING_ON
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma multi_compile_fragment _ _SCREEN_SPACE_OCCLUSION</span></span></span></code></pre></div>
<p>If unlit, the fog and instancing ones may be the only ones needed.</p>
<p>There&rsquo;s also a bunch of shader_feature ones that shaders could include, you can see the templates (below) for common ones (e.g. _NORMALMAP) but they depend on the shader and shouldn&rsquo;t always be included unless supporting what the keyword does.</p>
<hr>
<h2 id="summary-functions">Common Functions/Macros :</h2>
<p class="">
<!-- table formatting -->
<div class="tbl w40">
</p>
<table>
<thead>
<tr>
<th style="text-align:left">Built-In</th>
<th style="text-align:left">URP Equivalent</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>TRANSFORM_TEX(uv, textureName)</code></td>
<td style="text-align:left"><code>TRANSFORM_TEX(uv, textureName)</code></td>
</tr>
<tr>
<td style="text-align:left"><code>tex2D</code>, <code>tex2Dlod</code>, etc</td>
<td style="text-align:left"><code>SAMPLE_TEXTURE2D</code>, <code>SAMPLE_TEXTURE2D_LOD</code>, etc. See above</td>
</tr>
<tr>
<td style="text-align:left"><code>UnityObjectToClipPos(positionOS)</code></td>
<td style="text-align:left"><code>TransformObjectToHClip(positionOS)</code>, or use <code>GetVertexPositionInputs().positionCS</code></td>
</tr>
<tr>
<td style="text-align:left"><code>UnityObjectToWorldNormal(normalOS)</code></td>
<td style="text-align:left"><code>TransformObjectToWorldNormal(normalOS)</code>, or use <code>GetVertexNormalInputs().normalWS</code></td>
</tr>
<tr>
<td style="text-align:left"><code>ComputeScreenPos(positionCS)</code></td>
<td style="text-align:left"><code>ComputeScreenPos(positionCS)</code>, though <a href="https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderVariablesFunctions.deprecated.hlsl">deprecated in Unity 2021 / URP v11+</a>. Should use <code>GetVertexPositionInputs().positionNDC</code> instead</td>
</tr>
<tr>
<td style="text-align:left"><code>ComputeGrabScreenPos(positionCS)</code></td>
<td style="text-align:left">GrabPass is not supported in URP</td>
</tr>
<tr>
<td style="text-align:left"><code>WorldSpaceViewDir(positionOS)</code></td>
<td style="text-align:left">Calculate <code>positionWS</code> and use the below function instead</td>
</tr>
<tr>
<td style="text-align:left"><code>UnityWorldSpaceViewDir(positionWS)</code></td>
<td style="text-align:left"><code>GetWorldSpaceViewDir(positionWS)</code> (added to <a href="https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderVariablesFunctions.hlsl">ShaderVariablesFunctions.hlsl</a> in v9+). For versions prior, copy it out. If you need it normalised, can use <code>GetWorldSpaceNormalizeViewDir(positionWS)</code> instead.</td>
</tr>
<tr>
<td style="text-align:left"><code>WorldSpaceLightDir(positionOS)</code></td>
<td style="text-align:left">See below</td>
</tr>
<tr>
<td style="text-align:left"><code>UnityWorldSpaceLightDir(positionWS)</code> / <code>_WorldSpaceLightPos0</code></td>
<td style="text-align:left">For Main Directional Light, use <code>GetMainLight().direction</code>. See <a href="https://github.com/Unity-Technologies/Graphics/blob/v10.5.0/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl">Lighting.hlsl</a></td>
</tr>
<tr>
<td style="text-align:left"><code>Shade4PointLights(...)</code></td>
<td style="text-align:left">No direct equivalent really, but built-in uses this for vertex lighting in Forward, so see below.</td>
</tr>
<tr>
<td style="text-align:left"><code>ShadeVertexLights(vertex, normal)</code></td>
<td style="text-align:left"><code>VertexLighting(positionWS, normalWS)</code> in <a href="https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl">Lighting.hlsl</a></td>
</tr>
<tr>
<td style="text-align:left"><code>ShadeSH9(half4(worldNormal,1))</code></td>
<td style="text-align:left"><code>SampleSH(normalWS)</code>, but use <code>SAMPLE_GI(input.lightmapUV, input.vertexSH, inputData.normalWS)</code> macro / <code>SampleSHVertex/SampleSHPixel</code> functions in <a href="https://github.com/Unity-Technologies/Graphics/blob/v10.5.0/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl">Lighting.hlsl</a>. See <a href="https://github.com/Unity-Technologies/Graphics/blob/v10.3.2/com.unity.render-pipelines.universal/Shaders/LitForwardPass.hlsl">LitForwardPass.hlsl</a> for example</td>
</tr>
<tr>
<td style="text-align:left"><code>UNITY_FOG_COORDS(n)</code></td>
<td style="text-align:left"><code>float fogFactor : TEXCOORDn</code></td>
</tr>
<tr>
<td style="text-align:left"><code>UNITY_TRANSFER_FOG(o, positionCS)</code></td>
<td style="text-align:left"><code>OUT.fogFactor = ComputeFogFactor(positionCS.z)</code></td>
</tr>
<tr>
<td style="text-align:left"><code>UNITY_APPLY_FOG(fogCoord, color, fogColor)</code></td>
<td style="text-align:left"><code>color.rgb = MixFog(color.rgb, fogCoord)</code></td>
</tr>
<tr>
<td style="text-align:left"><code>UNITY_APPLY_FOG_COLOR(fogCoord, color)</code></td>
<td style="text-align:left"><code>color.rgb = MixFogColor(color.rgb, fogColor.rgb, fogCoord)</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Linear01Depth(z)</code></td>
<td style="text-align:left"><code>Linear01Depth(z, _ZBufferParams)</code></td>
</tr>
<tr>
<td style="text-align:left"><code>LinearEyeDepth(z)</code></td>
<td style="text-align:left"><code>LinearEyeDepth(z, _ZBufferParams)</code></td>
</tr>
<tr>
<td style="text-align:left"><code>ParallaxOffset(h, height, viewDirTS)</code></td>
<td style="text-align:left"><code>ParallaxOffset1Step(h, amplitude, viewDirTS)</code> if in v10.1+ (for versions prior, copy function out). See <a href="https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.core/ShaderLibrary/ParallaxMapping.hlsl">ParallaxMapping.hlsl</a></td>
</tr>
<tr>
<td style="text-align:left"><code>Luminance(rgb)</code></td>
<td style="text-align:left"><code>Luminance(rgb)</code>, See <a href="https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl">Color.hlsl</a></td>
</tr>
<tr>
<td style="text-align:left"><code>V2F_SHADOW_CASTER</code></td>
<td style="text-align:left">Equivalent is roughly just <code>float4 positionCS   : SV_POSITION;</code> but see the <a href="#shadowcaster">ShadowCaster</a> section.</td>
</tr>
<tr>
<td style="text-align:left"><code>TRANSFER_SHADOW_CASTER_NORMALOFFSET</code></td>
<td style="text-align:left">See <code>GetShadowPositionHClip(input)</code> example in <a href="https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.universal/Shaders/ShadowCasterPass.hlsl">ShadowCasterPass.hlsl</a>, also see above</td>
</tr>
<tr>
<td style="text-align:left"><code>SHADOW_CASTER_FRAGMENT</code></td>
<td style="text-align:left"><code>return 0;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>SHADOW_COORDS(1)</code></td>
<td style="text-align:left"><code>float4 shadowCoord : TEXCOORD1; </code></td>
</tr>
<tr>
<td style="text-align:left"><code>TRANSFER_SHADOW(o)</code></td>
<td style="text-align:left"><code>TransformWorldToShadowCoord(inputData.positionWS)</code></td>
</tr>
<tr>
<td style="text-align:left"><code>SHADOW_ATTENUATION(i)</code></td>
<td style="text-align:left"><code>MainLightRealtimeShadow(shadowCoord)</code>, though <code>GetMainLight(shadowCoord)</code> will also handle it. See <a href="https://github.com/Unity-Technologies/Graphics/blob/v10.5.0/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl">Lighting.hlsl</a> and <a href="https://github.com/Unity-Technologies/Graphics/blob/v10.5.0/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl">Shadows.hlsl</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p class="">
<!-- table formatting end -->
</div>
</p>
<p>(If there&rsquo;s any commonly used functions from built-in not listed here, let me know and I&rsquo;ll look into adding them!)</p>
<hr>
<h1 id="templates">Templates</h1>
<p>You can find some templates/examples that I&rsquo;ve shared on my <a href="https://github.com/Cyanilux/URP_ShaderCodeTemplates">github here</a>. It includes :</p>
<ul>
<li>Opaque Unlit Shader Template</li>
<li>Transparent Unlit Shader Template</li>
<li>Opaque Unlit+ Shader Template
<ul>
<li>(includes optional Alpha Clipping and ShadowCaster, DepthOnly &amp; DepthNormals passes)</li>
</ul>
</li>
<li>Diffuse Lit Shader Template
<ul>
<li>(Ambient / Baked GI &amp; Lambert Diffuse shading from Main Directional Light only)</li>
</ul>
</li>
<li>Simple Lit Shader Template
<ul>
<li>(Lambert Diffuse &amp; Blinn-Phong Specular. Uses <code>UniversalFragmentBlinnPhong</code> method from Lighting.hlsl, similar to URP/SimpleLit shader)</li>
</ul>
</li>
<li>PBR Lit Shader Template
<ul>
<li>(Physically Based Rendering lighting model. Uses <code>UniversalFragmentPBR</code> method from Lighting.hlsl, similar to URP/Lit shader. Note, doesn&rsquo;t include height/parallax mapping, detail maps or clear coat. Split into URP_PBRLitTemplate.shader, PBRSurface.hlsl and PBRInput.hlsl for organisation &amp; Meta pass support)</li>
</ul>
</li>
</ul>
<br><hr>

<div style="display:block;text-align: center">
<h2>Thanks for reading!</h2>
<p> If this post helped, consider sharing a link with others!</p>
</div>

<div class="footer-btns">
<script type='text/javascript' src='https://storage.ko-fi.com/cdn/widget/Widget_2.js'></script><script type='text/javascript'>kofiwidget2.init('Support me on Ko-fi! ✨', '#e664fa', 'X8X0J5MD6');kofiwidget2.draw();</script>
<a href="http://discord.gg/2V93q9w">
<div class="btn-discord">
<img class="img" src="https://www.cyanilux.com/logo-discord-2.png" alt="Discord" style="width:22px">
Join my discord! 💬
</img>
</div>
</a>
</div>


        </div>
        </br>
<p class="footer">
<a class="small-text" href="https://twitter.com/Cyanilux">© Cyanilux</a>
	<p class="small-text" style="text-align:center;">
	
	
	
		<a href="https://www.cyanilux.com/#license">
		
		License / Usage
		</a>
		 &#8212; 
	
		<a href="https://www.cyanilux.com/cookies">
		
		Cookies & Privacy
		</a>
		 &#8212; 
	
		<a href="https://www.cyanilux.com/index.xml">
		
		RSS Feed
		</a>
		
	
	</p>
</p>
</br>
    </body>
</html>
